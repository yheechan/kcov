function: __bswap_32
function: __bswap_64
function: __uint16_identity
function: __uint32_identity
function: __uint64_identity
function: error
if (errnum)
    fprintf(stdout, "%s: %s: %s\n", prog, mesg, strerror(errnum));
else
    fprintf(stdout, "%s: %s\n", prog, mesg);
===================

function: fatal
function: xmalloc
if (size && !result)
    fatal("memory exhausted", 0);
===================

function: xrealloc
if (ptr)
    result = realloc(ptr, size);
else
    result = malloc(size);
===================

if (size && !result)
    fatal("memory exhausted", 0);
===================

function: reset
if (!initialized) {
    initialized = 1;
    bufsalloc = ((8192) > (getpagesize()) ? (8192) : (getpagesize()));
    bufalloc = 5 * bufsalloc;
    buffer = valloc(bufalloc + 1);
    if (!buffer)
        fatal("memory exhausted", 0);
    bufbeg = buffer;
    buflim = buffer;
}
===================

if (!buffer)
    fatal("memory exhausted", 0);
===================

if (fstat(fd, &bufstat) < 0 || !((((bufstat.st_mode)) & 61440) == (32768)))
    bufmapped = 0;
else {
    bufmapped = 1;
    bufoffset = lseek(fd, 0, 1);
}
===================

function: fillbuf
if (pagesize == 0 && (pagesize = getpagesize()) == 0)
    abort();
===================

if (save > bufsalloc) {
    while (save > bufsalloc)
        bufsalloc *= 2;
    bufalloc = 5 * bufsalloc;
    nbuffer = valloc(bufalloc + 1);
    if (!nbuffer)
        fatal("memory exhausted", 0);
} else
    nbuffer = buffer;
===================

if (!nbuffer)
    fatal("memory exhausted", 0);
===================

if (bufmapped && bufoffset % pagesize == 0 && bufstat.st_size - bufoffset >= bufalloc - bufsalloc) {
    maddr = buffer + bufsalloc;
    maddr = mmap(maddr, bufalloc - bufsalloc, 1 | 2, 2 | 16, bufdesc, bufoffset);
    if (maddr == (caddr_t)-1) {
        fprintf(stdout, "%s: warning: %s: %s\n", filename, strerror((*__errno_location())));
        goto tryread;
    }
    cc = bufalloc - bufsalloc;
    bufoffset += cc;
} else {
  tryread:
    if (bufmapped) {
        bufmapped = 0;
        lseek(bufdesc, bufoffset, 0);
    }
    cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
}
===================

if (maddr == (caddr_t)-1) {
    fprintf(stdout, "%s: warning: %s: %s\n", filename, strerror((*__errno_location())));
    goto tryread;
}
===================

if (bufmapped) {
    bufmapped = 0;
    lseek(bufdesc, bufoffset, 0);
}
===================

if (cc > 0)
    buflim = buffer + bufsalloc + cc;
else
    buflim = buffer + bufsalloc;
===================

function: nlscan
if (*beg == '\n')
    ++totalnl;
===================

function: prline
if (out_file)
    printf("%s%c", filename, sep);
===================

if (out_line) {
    nlscan(beg);
    printf("%d%c", ++totalnl, sep);
    lastnl = lim;
}
===================

if (out_byte)
    printf("%lu%c", totalcc + (beg - bufbeg), sep);
===================

if (ferror(stdout))
    error("writing output", (*__errno_location()));
===================

function: prpending
if (!lastout)
    lastout = bufbeg;
===================

if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
    ++nl;
else
    nl = lim;
===================

function: prtext
if (!out_quiet && pending > 0)
    prpending(beg);
===================

if (!out_quiet) {
    bp = lastout ? lastout : bufbeg;
    for (i = 0; i < out_before; ++i)
        if (p > bp)
            do 
                --p;
            while (p > bp && p[-1] != '\n');
    if ((out_before || out_after) && used && p != lastout)
        puts("--");
    while (p < beg)
        {
            nl = memchr(p, '\n', beg - p);
            prline(p, nl + 1, '-');
            p = nl + 1;
        }
}
===================

if (p > bp)
    do 
        --p;
    while (p > bp && p[-1] != '\n');
===================

if ((out_before || out_after) && used && p != lastout)
    puts("--");
===================

if (nlinesp) {
    for (n = 0; p < lim; ++n) {
        if ((nl = memchr(p, '\n', lim - p)) != 0)
            ++nl;
        else
            nl = lim;
        if (!out_quiet)
            prline(p, nl, ':');
        p = nl;
    }
    *nlinesp = n;
} else if (!out_quiet)
    prline(beg, lim, ':');
===================

if ((nl = memchr(p, '\n', lim - p)) != 0)
    ++nl;
else
    nl = lim;
===================

if (!out_quiet)
    prline(p, nl, ':');
===================

if (!out_quiet)
    prline(beg, lim, ':');
===================

function: grepbuf
if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
    break;
===================

if (!out_invert) {
    prtext(b, endp, (int *)0);
    nlines += 1;
} else if (p < b) {
    prtext(p, b, &n);
    nlines += n;
}
===================

if (p < b) {
    prtext(p, b, &n);
    nlines += n;
}
===================

if (out_invert && p < lim) {
    prtext(p, lim, &n);
    nlines += n;
}
===================

function: grep
if (fillbuf(save) < 0) {
    error(filename, (*__errno_location()));
    return nlines;
}
===================

if (lastout)
    lastout = bufbeg;
===================

if (buflim - bufbeg == save)
    break;
===================

if (beg < lim) {
    nlines += grepbuf(beg, lim);
    if (pending)
        prpending(lim);
}
===================

if (pending)
    prpending(lim);
===================

if (beg != lastout)
    lastout = 0;
===================

if (out_line)
    nlscan(beg);
===================

if (residue) {
    nlines += grepbuf(bufbeg + save - residue, buflim);
    if (pending)
        prpending(buflim);
}
===================

if (pending)
    prpending(buflim);
===================

function: usage
function: setmatcher
if (strcmp(name, matchers[i].name) == 0) {
    compile = matchers[i].compile;
    execute = matchers[i].execute;
    return 1;
}
===================

function: main
if (prog && strrchr(prog, '/'))
    prog = strrchr(prog, '/') + 1;
===================

if (out_after < 0)
    usage();
===================

if (out_before < 0)
    usage();
===================

if (matcher && strcmp(matcher, "egrep") != 0)
    fatal("you may specify only one of -E, -F, or -G", 0);
===================

if (matcher && strcmp(matcher, "fgrep") != 0)
    fatal("you may specify only one of -E, -F, or -G", 0);
===================

if (matcher && strcmp(matcher, "grep") != 0)
    fatal("you may specify only one of -E, -F, or -G", 0);
===================

if (matcher)
    fatal("matcher already specified", 0);
===================

if (keyfound)
    keys[keycc++] = '\n';
===================

if (!fp)
    fatal(optarg, (*__errno_location()));
===================

if (keyfound)
    keys[keycc++] = '\n';
===================

if (keycc == keyalloc)
    keys = xrealloc(keys, keyalloc *= 2);
===================

if (fp != stdin)
    fclose(fp);
===================

if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
    --keycc;
===================

if (!keyfound)
    if (optind < argc) {
        keys = argv[optind++];
        keycc = strlen(keys);
    } else
        usage();
===================

if (optind < argc) {
    keys = argv[optind++];
    keycc = strlen(keys);
} else
    usage();
===================

if (!matcher)
    matcher = prog;
===================

if (!setmatcher(matcher) && !setmatcher("default"))
    abort();
===================

if (argc - optind > 1 && !no_filenames)
    out_file = 1;
===================

if (optind < argc)
    while (optind < argc)
        {
            desc = strcmp(argv[optind], "-") ? open(argv[optind], 0) : 0;
            if (desc < 0) {
                if (!suppress_errors)
                    error(argv[optind], (*__errno_location()));
            } else {
                filename = desc == 0 ? "(standard input)" : argv[optind];
                count = grep(desc);
                if (count_matches) {
                    if (out_file)
                        printf("%s:", filename);
                    printf("%d\n", count);
                }
                if (count) {
                    status = 0;
                    if (list_files == 1)
                        printf("%s\n", filename);
                } else if (list_files == -1)
                    printf("%s\n", filename);
            }
            if (desc != 0)
                close(desc);
            ++optind;
        }
else {
    filename = "(standard input)";
    count = grep(0);
    if (count_matches)
        printf("%d\n", count);
    if (count) {
        status = 0;
        if (list_files == 1)
            printf("(standard input)\n");
    } else if (list_files == -1)
        printf("(standard input)\n");
}
===================

if (desc < 0) {
    if (!suppress_errors)
        error(argv[optind], (*__errno_location()));
} else {
    filename = desc == 0 ? "(standard input)" : argv[optind];
    count = grep(desc);
    if (count_matches) {
        if (out_file)
            printf("%s:", filename);
        printf("%d\n", count);
    }
    if (count) {
        status = 0;
        if (list_files == 1)
            printf("%s\n", filename);
    } else if (list_files == -1)
        printf("%s\n", filename);
}
===================

if (!suppress_errors)
    error(argv[optind], (*__errno_location()));
===================

if (count_matches) {
    if (out_file)
        printf("%s:", filename);
    printf("%d\n", count);
}
===================

if (out_file)
    printf("%s:", filename);
===================

if (count) {
    status = 0;
    if (list_files == 1)
        printf("%s\n", filename);
} else if (list_files == -1)
    printf("%s\n", filename);
===================

if (list_files == 1)
    printf("%s\n", filename);
===================

if (list_files == -1)
    printf("%s\n", filename);
===================

if (desc != 0)
    close(desc);
===================

if (count_matches)
    printf("%d\n", count);
===================

if (count) {
    status = 0;
    if (list_files == 1)
        printf("(standard input)\n");
} else if (list_files == -1)
    printf("(standard input)\n");
===================

if (list_files == 1)
    printf("(standard input)\n");
===================

if (list_files == -1)
    printf("(standard input)\n");
===================

function: init_syntax_once
if (done)
    return;
===================

function: re_set_syntax
function: regex_compile
if (compile_stack.stack == ((void *)0))
    return REG_ESPACE;
===================

if (bufp->allocated == 0) {
    if (bufp->buffer) {
        ((bufp->buffer) = (unsigned char *)realloc(bufp->buffer, (32) * sizeof(unsigned char)));
    } else {
        bufp->buffer = ((unsigned char *)malloc((32) * sizeof(unsigned char)));
    }
    if (!bufp->buffer)
        return REG_ESPACE;
    bufp->allocated = 32;
}
===================

if (bufp->buffer) {
    ((bufp->buffer) = (unsigned char *)realloc(bufp->buffer, (32) * sizeof(unsigned char)));
} else {
    bufp->buffer = ((unsigned char *)malloc((32) * sizeof(unsigned char)));
}
===================

if (!bufp->buffer)
    return REG_ESPACE;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (p == pattern + 1 || syntax & ((((1) << 1) << 1) << 1) || at_begline_loc_p(pattern, p, syntax))
    do {
        while (b - bufp->buffer + (1) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(begline);
    } while (0);
else
    goto normal_char;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (p == pend || syntax & ((((1) << 1) << 1) << 1) || at_endline_loc_p(p, pend, syntax))
    do {
        while (b - bufp->buffer + (1) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(endline);
    } while (0);
else
    goto normal_char;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if ((syntax & ((1) << 1)) || (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
    goto normal_char;
===================

if (!laststart) {
    if (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1))
        return REG_BADRPT;
    else if (!(syntax & (((((1) << 1) << 1) << 1) << 1)))
        goto normal_char;
}
===================

if (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1))
    return REG_BADRPT;
else if (!(syntax & (((((1) << 1) << 1) << 1) << 1)))
    goto normal_char;
===================

if (!(syntax & (((((1) << 1) << 1) << 1) << 1)))
    goto normal_char;
===================

if (p == pend)
    break;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (c == '*' || (!(syntax & ((1) << 1)) && (c == '+' || c == '?')))
    ;
else if (syntax & ((1) << 1) && c == '\\') {
    if (p == pend)
        return REG_EESCAPE;
    do {
        if (p == pend)
            return REG_EEND;
        c1 = (unsigned char)*p++;
        if (translate)
            c1 = translate[c1];
    } while (0);
    if (!(c1 == '+' || c1 == '?')) {
        p--;
        p--;
        break;
    }
    c = c1;
} else {
    p--;
    break;
}
===================

if (syntax & ((1) << 1) && c == '\\') {
    if (p == pend)
        return REG_EESCAPE;
    do {
        if (p == pend)
            return REG_EEND;
        c1 = (unsigned char)*p++;
        if (translate)
            c1 = translate[c1];
    } while (0);
    if (!(c1 == '+' || c1 == '?')) {
        p--;
        p--;
        break;
    }
    c = c1;
} else {
    p--;
    break;
}
===================

if (p == pend)
    return REG_EESCAPE;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c1 = translate[c1];
===================

if (!(c1 == '+' || c1 == '?')) {
    p--;
    p--;
    break;
}
===================

if (!laststart)
    break;
===================

if (many_times_ok) {
    ;
    while (b - bufp->buffer + (3) > bufp->allocated)
        do {
            unsigned char *old_buffer = bufp->buffer;
            if (bufp->allocated == (1L << 16))
                return REG_ESIZE;
            bufp->allocated <<= 1;
            if (bufp->allocated > (1L << 16))
                bufp->allocated = (1L << 16);
            bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
            if (bufp->buffer == ((void *)0))
                return REG_ESPACE;
            if (old_buffer != bufp->buffer) {
                b = (b - old_buffer) + bufp->buffer;
                begalt = (begalt - old_buffer) + bufp->buffer;
                if (fixup_alt_jump)
                    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                if (laststart)
                    laststart = (laststart - old_buffer) + bufp->buffer;
                if (pending_exact)
                    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
            }
        } while (0);
    if ((translate ? translate[(unsigned char)(*(p - 2))] : (*(p - 2))) == (translate ? translate[(unsigned char)('.')] : ('.')) && zero_times_ok && p < pend && (translate ? translate[(unsigned char)(*p)] : (*p)) == (translate ? translate[(unsigned char)('\n')] : ('\n')) && !(syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        store_op1(jump, b, (laststart) - (b) - 3);
        keep_string_p = 1;
    } else
        store_op1(maybe_pop_jump, b, (laststart - 3) - (b) - 3);
    b += 3;
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if ((translate ? translate[(unsigned char)(*(p - 2))] : (*(p - 2))) == (translate ? translate[(unsigned char)('.')] : ('.')) && zero_times_ok && p < pend && (translate ? translate[(unsigned char)(*p)] : (*p)) == (translate ? translate[(unsigned char)('\n')] : ('\n')) && !(syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    store_op1(jump, b, (laststart) - (b) - 3);
    keep_string_p = 1;
} else
    store_op1(maybe_pop_jump, b, (laststart - 3) - (b) - 3);
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (!zero_times_ok) {
    while (b - bufp->buffer + (3) > bufp->allocated)
        do {
            unsigned char *old_buffer = bufp->buffer;
            if (bufp->allocated == (1L << 16))
                return REG_ESIZE;
            bufp->allocated <<= 1;
            if (bufp->allocated > (1L << 16))
                bufp->allocated = (1L << 16);
            bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
            if (bufp->buffer == ((void *)0))
                return REG_ESPACE;
            if (old_buffer != bufp->buffer) {
                b = (b - old_buffer) + bufp->buffer;
                begalt = (begalt - old_buffer) + bufp->buffer;
                if (fixup_alt_jump)
                    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                if (laststart)
                    laststart = (laststart - old_buffer) + bufp->buffer;
                if (pending_exact)
                    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
            }
        } while (0);
    insert_op1(dummy_failure_jump, laststart, (laststart + 6) - (laststart) - 3, b);
    b += 3;
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (p == pend)
    return REG_EBRACK;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (*p == '^')
    p++;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if ((re_opcode_t)b[-2] == charset_not && (syntax & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
    (b[((unsigned char)('\n')) / 8] |= 1 << (((unsigned char)'\n') % 8));
===================

if (p == pend)
    return REG_EBRACK;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if ((syntax & (1)) && c == '\\') {
    if (p == pend)
        return REG_EESCAPE;
    do {
        if (p == pend)
            return REG_EEND;
        c1 = (unsigned char)*p++;
        if (translate)
            c1 = translate[c1];
    } while (0);
    (b[((unsigned char)(c1)) / 8] |= 1 << (((unsigned char)c1) % 8));
    continue;
}
===================

if (p == pend)
    return REG_EESCAPE;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c1 = translate[c1];
===================

if (c == ']' && p != p1 + 1)
    break;
===================

if (had_char_class && c == '-' && *p != ']')
    return REG_ERANGE;
===================

if (c == '-' && !(p - 2 >= pattern && p[-2] == '[') && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^') && *p != ']') {
    reg_errcode_t ret = compile_range(&p, pend, translate, syntax, b);
    if (ret != REG_NOERROR)
        return ret;
} else if (p[0] == '-' && p[1] != ']') {
    reg_errcode_t ret;
    do {
        if (p == pend)
            return REG_EEND;
        c1 = (unsigned char)*p++;
        if (translate)
            c1 = translate[c1];
    } while (0);
    ret = compile_range(&p, pend, translate, syntax, b);
    if (ret != REG_NOERROR)
        return ret;
} else if (syntax & (((1) << 1) << 1) && c == '[' && *p == ':') {
    char str[7];
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    c1 = 0;
    if (p == pend)
        return REG_EBRACK;
    for (;;) {
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (c == ':' || c == ']' || p == pend || c1 == 6)
            break;
        str[c1++] = c;
    }
    str[c1] = '\x00';
    if (c == ':' && *p == ']') {
        int ch;
        boolean is_alnum = ((strcmp(str, "alnum") == 0));
        boolean is_alpha = ((strcmp(str, "alpha") == 0));
        boolean is_blank = ((strcmp(str, "blank") == 0));
        boolean is_cntrl = ((strcmp(str, "cntrl") == 0));
        boolean is_digit = ((strcmp(str, "digit") == 0));
        boolean is_graph = ((strcmp(str, "graph") == 0));
        boolean is_lower = ((strcmp(str, "lower") == 0));
        boolean is_print = ((strcmp(str, "print") == 0));
        boolean is_punct = ((strcmp(str, "punct") == 0));
        boolean is_space = ((strcmp(str, "space") == 0));
        boolean is_upper = ((strcmp(str, "upper") == 0));
        boolean is_xdigit = ((strcmp(str, "xdigit") == 0));
        if (!(((strcmp(str, "alpha") == 0)) || ((strcmp(str, "upper") == 0)) || ((strcmp(str, "lower") == 0)) || ((strcmp(str, "digit") == 0)) || ((strcmp(str, "alnum") == 0)) || ((strcmp(str, "xdigit") == 0)) || ((strcmp(str, "space") == 0)) || ((strcmp(str, "print") == 0)) || ((strcmp(str, "punct") == 0)) || ((strcmp(str, "graph") == 0)) || ((strcmp(str, "cntrl") == 0)) || ((strcmp(str, "blank") == 0))))
            return REG_ECTYPE;
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (p == pend)
            return REG_EBRACK;
        for (ch = 0; ch < 1 << 8; ch++) {
            if ((is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit))))
                (b[((unsigned char)(ch)) / 8] |= 1 << (((unsigned char)ch) % 8));
        }
        had_char_class = 1;
    } else {
        c1++;
        while (c1--)
            p--;
        (b[((unsigned char)('[')) / 8] |= 1 << (((unsigned char)'[') % 8));
        (b[((unsigned char)(':')) / 8] |= 1 << (((unsigned char)':') % 8));
        had_char_class = 0;
    }
} else {
    had_char_class = 0;
    (b[((unsigned char)(c)) / 8] |= 1 << (((unsigned char)c) % 8));
}
===================

if (ret != REG_NOERROR)
    return ret;
===================

if (p[0] == '-' && p[1] != ']') {
    reg_errcode_t ret;
    do {
        if (p == pend)
            return REG_EEND;
        c1 = (unsigned char)*p++;
        if (translate)
            c1 = translate[c1];
    } while (0);
    ret = compile_range(&p, pend, translate, syntax, b);
    if (ret != REG_NOERROR)
        return ret;
} else if (syntax & (((1) << 1) << 1) && c == '[' && *p == ':') {
    char str[7];
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    c1 = 0;
    if (p == pend)
        return REG_EBRACK;
    for (;;) {
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (c == ':' || c == ']' || p == pend || c1 == 6)
            break;
        str[c1++] = c;
    }
    str[c1] = '\x00';
    if (c == ':' && *p == ']') {
        int ch;
        boolean is_alnum = ((strcmp(str, "alnum") == 0));
        boolean is_alpha = ((strcmp(str, "alpha") == 0));
        boolean is_blank = ((strcmp(str, "blank") == 0));
        boolean is_cntrl = ((strcmp(str, "cntrl") == 0));
        boolean is_digit = ((strcmp(str, "digit") == 0));
        boolean is_graph = ((strcmp(str, "graph") == 0));
        boolean is_lower = ((strcmp(str, "lower") == 0));
        boolean is_print = ((strcmp(str, "print") == 0));
        boolean is_punct = ((strcmp(str, "punct") == 0));
        boolean is_space = ((strcmp(str, "space") == 0));
        boolean is_upper = ((strcmp(str, "upper") == 0));
        boolean is_xdigit = ((strcmp(str, "xdigit") == 0));
        if (!(((strcmp(str, "alpha") == 0)) || ((strcmp(str, "upper") == 0)) || ((strcmp(str, "lower") == 0)) || ((strcmp(str, "digit") == 0)) || ((strcmp(str, "alnum") == 0)) || ((strcmp(str, "xdigit") == 0)) || ((strcmp(str, "space") == 0)) || ((strcmp(str, "print") == 0)) || ((strcmp(str, "punct") == 0)) || ((strcmp(str, "graph") == 0)) || ((strcmp(str, "cntrl") == 0)) || ((strcmp(str, "blank") == 0))))
            return REG_ECTYPE;
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (p == pend)
            return REG_EBRACK;
        for (ch = 0; ch < 1 << 8; ch++) {
            if ((is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit))))
                (b[((unsigned char)(ch)) / 8] |= 1 << (((unsigned char)ch) % 8));
        }
        had_char_class = 1;
    } else {
        c1++;
        while (c1--)
            p--;
        (b[((unsigned char)('[')) / 8] |= 1 << (((unsigned char)'[') % 8));
        (b[((unsigned char)(':')) / 8] |= 1 << (((unsigned char)':') % 8));
        had_char_class = 0;
    }
} else {
    had_char_class = 0;
    (b[((unsigned char)(c)) / 8] |= 1 << (((unsigned char)c) % 8));
}
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c1 = translate[c1];
===================

if (ret != REG_NOERROR)
    return ret;
===================

if (syntax & (((1) << 1) << 1) && c == '[' && *p == ':') {
    char str[7];
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    c1 = 0;
    if (p == pend)
        return REG_EBRACK;
    for (;;) {
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (c == ':' || c == ']' || p == pend || c1 == 6)
            break;
        str[c1++] = c;
    }
    str[c1] = '\x00';
    if (c == ':' && *p == ']') {
        int ch;
        boolean is_alnum = ((strcmp(str, "alnum") == 0));
        boolean is_alpha = ((strcmp(str, "alpha") == 0));
        boolean is_blank = ((strcmp(str, "blank") == 0));
        boolean is_cntrl = ((strcmp(str, "cntrl") == 0));
        boolean is_digit = ((strcmp(str, "digit") == 0));
        boolean is_graph = ((strcmp(str, "graph") == 0));
        boolean is_lower = ((strcmp(str, "lower") == 0));
        boolean is_print = ((strcmp(str, "print") == 0));
        boolean is_punct = ((strcmp(str, "punct") == 0));
        boolean is_space = ((strcmp(str, "space") == 0));
        boolean is_upper = ((strcmp(str, "upper") == 0));
        boolean is_xdigit = ((strcmp(str, "xdigit") == 0));
        if (!(((strcmp(str, "alpha") == 0)) || ((strcmp(str, "upper") == 0)) || ((strcmp(str, "lower") == 0)) || ((strcmp(str, "digit") == 0)) || ((strcmp(str, "alnum") == 0)) || ((strcmp(str, "xdigit") == 0)) || ((strcmp(str, "space") == 0)) || ((strcmp(str, "print") == 0)) || ((strcmp(str, "punct") == 0)) || ((strcmp(str, "graph") == 0)) || ((strcmp(str, "cntrl") == 0)) || ((strcmp(str, "blank") == 0))))
            return REG_ECTYPE;
        do {
            if (p == pend)
                return REG_EEND;
            c = (unsigned char)*p++;
            if (translate)
                c = translate[c];
        } while (0);
        if (p == pend)
            return REG_EBRACK;
        for (ch = 0; ch < 1 << 8; ch++) {
            if ((is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit))))
                (b[((unsigned char)(ch)) / 8] |= 1 << (((unsigned char)ch) % 8));
        }
        had_char_class = 1;
    } else {
        c1++;
        while (c1--)
            p--;
        (b[((unsigned char)('[')) / 8] |= 1 << (((unsigned char)'[') % 8));
        (b[((unsigned char)(':')) / 8] |= 1 << (((unsigned char)':') % 8));
        had_char_class = 0;
    }
} else {
    had_char_class = 0;
    (b[((unsigned char)(c)) / 8] |= 1 << (((unsigned char)c) % 8));
}
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (p == pend)
    return REG_EBRACK;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (c == ':' || c == ']' || p == pend || c1 == 6)
    break;
===================

if (c == ':' && *p == ']') {
    int ch;
    boolean is_alnum = ((strcmp(str, "alnum") == 0));
    boolean is_alpha = ((strcmp(str, "alpha") == 0));
    boolean is_blank = ((strcmp(str, "blank") == 0));
    boolean is_cntrl = ((strcmp(str, "cntrl") == 0));
    boolean is_digit = ((strcmp(str, "digit") == 0));
    boolean is_graph = ((strcmp(str, "graph") == 0));
    boolean is_lower = ((strcmp(str, "lower") == 0));
    boolean is_print = ((strcmp(str, "print") == 0));
    boolean is_punct = ((strcmp(str, "punct") == 0));
    boolean is_space = ((strcmp(str, "space") == 0));
    boolean is_upper = ((strcmp(str, "upper") == 0));
    boolean is_xdigit = ((strcmp(str, "xdigit") == 0));
    if (!(((strcmp(str, "alpha") == 0)) || ((strcmp(str, "upper") == 0)) || ((strcmp(str, "lower") == 0)) || ((strcmp(str, "digit") == 0)) || ((strcmp(str, "alnum") == 0)) || ((strcmp(str, "xdigit") == 0)) || ((strcmp(str, "space") == 0)) || ((strcmp(str, "print") == 0)) || ((strcmp(str, "punct") == 0)) || ((strcmp(str, "graph") == 0)) || ((strcmp(str, "cntrl") == 0)) || ((strcmp(str, "blank") == 0))))
        return REG_ECTYPE;
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    if (p == pend)
        return REG_EBRACK;
    for (ch = 0; ch < 1 << 8; ch++) {
        if ((is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit))))
            (b[((unsigned char)(ch)) / 8] |= 1 << (((unsigned char)ch) % 8));
    }
    had_char_class = 1;
} else {
    c1++;
    while (c1--)
        p--;
    (b[((unsigned char)('[')) / 8] |= 1 << (((unsigned char)'[') % 8));
    (b[((unsigned char)(':')) / 8] |= 1 << (((unsigned char)':') % 8));
    had_char_class = 0;
}
===================

if (!(((strcmp(str, "alpha") == 0)) || ((strcmp(str, "upper") == 0)) || ((strcmp(str, "lower") == 0)) || ((strcmp(str, "digit") == 0)) || ((strcmp(str, "alnum") == 0)) || ((strcmp(str, "xdigit") == 0)) || ((strcmp(str, "space") == 0)) || ((strcmp(str, "print") == 0)) || ((strcmp(str, "punct") == 0)) || ((strcmp(str, "graph") == 0)) || ((strcmp(str, "cntrl") == 0)) || ((strcmp(str, "blank") == 0))))
    return REG_ECTYPE;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (p == pend)
    return REG_EBRACK;
===================

if ((is_alnum && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalnum))) || (is_alpha && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISalpha))) || (is_blank && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISblank))) || (is_cntrl && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_IScntrl))) || (is_digit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISdigit))) || (is_graph && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISgraph))) || (is_lower && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISlower))) || (is_print && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISprint))) || (is_punct && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISpunct))) || (is_space && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISspace))) || (is_upper && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISupper))) || (is_xdigit && (1 && ((*__ctype_b_loc())[(int)((ch))] & (unsigned short)_ISxdigit))))
    (b[((unsigned char)(ch)) / 8] |= 1 << (((unsigned char)ch) % 8));
===================

if (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto handle_open;
else
    goto normal_char;
===================

if (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto handle_close;
else
    goto normal_char;
===================

if (syntax & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto handle_alt;
else
    goto normal_char;
===================

if (syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto handle_alt;
else
    goto normal_char;
===================

if (syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto handle_interval;
else
    goto normal_char;
===================

if (p == pend)
    return REG_EESCAPE;
===================

if (p == pend)
    return REG_EEND;
===================

if (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_backslash;
===================

if ((compile_stack.avail == compile_stack.size)) {
    ((compile_stack.stack) = (compile_stack_elt_t *)realloc(compile_stack.stack, (compile_stack.size << 1) * sizeof(compile_stack_elt_t)));
    if (compile_stack.stack == ((void *)0))
        return REG_ESPACE;
    compile_stack.size <<= 1;
}
===================

if (compile_stack.stack == ((void *)0))
    return REG_ESPACE;
===================

if (regnum <= 255) {
    (compile_stack.stack[compile_stack.avail]).inner_group_offset = b - bufp->buffer + 2;
    do {
        while (b - bufp->buffer + (3) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(start_memory);
        *b++ = (unsigned char)(regnum);
        *b++ = (unsigned char)(0);
    } while (0);
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (syntax & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_backslash;
===================

if ((compile_stack.avail == 0))
    if (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        goto normal_backslash;
    else
        return REG_ERPAREN;
===================

if (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_backslash;
else
    return REG_ERPAREN;
===================

if (fixup_alt_jump) {
    do {
        while (b - bufp->buffer + (1) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(push_dummy_failure);
    } while (0);
    store_op1(jump_past_alt, fixup_alt_jump, (b - 1) - (fixup_alt_jump) - 3);
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if ((compile_stack.avail == 0))
    if (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        goto normal_char;
    else
        return REG_ERPAREN;
===================

if (syntax & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
else
    return REG_ERPAREN;
===================

if (this_group_regnum <= 255) {
    unsigned char *inner_group_loc = bufp->buffer + (compile_stack.stack[compile_stack.avail]).inner_group_offset;
    *inner_group_loc = regnum - this_group_regnum;
    do {
        while (b - bufp->buffer + (3) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(stop_memory);
        *b++ = (unsigned char)(this_group_regnum);
        *b++ = (unsigned char)(regnum - this_group_regnum);
    } while (0);
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || syntax & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_backslash;
===================

if (syntax & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (fixup_alt_jump)
    store_op1(jump_past_alt, fixup_alt_jump, (b) - (fixup_alt_jump) - 3);
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (!(syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) || (p - 2 == pattern && p == pend))
    goto normal_backslash;
===================

if (p == pend) {
    if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        goto unfetch_interval;
    else
        return REG_EBRACE;
}
===================

if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto unfetch_interval;
else
    return REG_EBRACE;
===================

if (p != pend) {
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    while ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
        {
            if (lower_bound < 0)
                lower_bound = 0;
            lower_bound = lower_bound * 10 + c - '0';
            if (p == pend)
                break;
            do {
                if (p == pend)
                    return REG_EEND;
                c = (unsigned char)*p++;
                if (translate)
                    c = translate[c];
            } while (0);
        }
}
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (lower_bound < 0)
    lower_bound = 0;
===================

if (p == pend)
    break;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (c == ',') {
    {
        if (p != pend) {
            do {
                if (p == pend)
                    return REG_EEND;
                c = (unsigned char)*p++;
                if (translate)
                    c = translate[c];
            } while (0);
            while ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
                {
                    if (upper_bound < 0)
                        upper_bound = 0;
                    upper_bound = upper_bound * 10 + c - '0';
                    if (p == pend)
                        break;
                    do {
                        if (p == pend)
                            return REG_EEND;
                        c = (unsigned char)*p++;
                        if (translate)
                            c = translate[c];
                    } while (0);
                }
        }
    }
    ;
    if (upper_bound < 0)
        upper_bound = ((1 << 15) - 1);
} else
    upper_bound = lower_bound;
===================

if (p != pend) {
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
    while ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
        {
            if (upper_bound < 0)
                upper_bound = 0;
            upper_bound = upper_bound * 10 + c - '0';
            if (p == pend)
                break;
            do {
                if (p == pend)
                    return REG_EEND;
                c = (unsigned char)*p++;
                if (translate)
                    c = translate[c];
            } while (0);
        }
}
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (upper_bound < 0)
    upper_bound = 0;
===================

if (p == pend)
    break;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (upper_bound < 0)
    upper_bound = ((1 << 15) - 1);
===================

if (lower_bound < 0 || upper_bound > ((1 << 15) - 1) || lower_bound > upper_bound) {
    if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        goto unfetch_interval;
    else
        return REG_BADBR;
}
===================

if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto unfetch_interval;
else
    return REG_BADBR;
===================

if (!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (c != '\\')
        return REG_EBRACE;
    do {
        if (p == pend)
            return REG_EEND;
        c = (unsigned char)*p++;
        if (translate)
            c = translate[c];
    } while (0);
}
===================

if (c != '\\')
    return REG_EBRACE;
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (c != '}') {
    if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        goto unfetch_interval;
    else
        return REG_BADBR;
}
===================

if (syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto unfetch_interval;
else
    return REG_BADBR;
===================

if (!laststart) {
    if (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1))
        return REG_BADRPT;
    else if (syntax & (((((1) << 1) << 1) << 1) << 1))
        laststart = b;
    else
        goto unfetch_interval;
}
===================

if (syntax & ((((((1) << 1) << 1) << 1) << 1) << 1))
    return REG_BADRPT;
else if (syntax & (((((1) << 1) << 1) << 1) << 1))
    laststart = b;
else
    goto unfetch_interval;
===================

if (syntax & (((((1) << 1) << 1) << 1) << 1))
    laststart = b;
else
    goto unfetch_interval;
===================

if (upper_bound == 0) {
    while (b - bufp->buffer + (3) > bufp->allocated)
        do {
            unsigned char *old_buffer = bufp->buffer;
            if (bufp->allocated == (1L << 16))
                return REG_ESIZE;
            bufp->allocated <<= 1;
            if (bufp->allocated > (1L << 16))
                bufp->allocated = (1L << 16);
            bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
            if (bufp->buffer == ((void *)0))
                return REG_ESPACE;
            if (old_buffer != bufp->buffer) {
                b = (b - old_buffer) + bufp->buffer;
                begalt = (begalt - old_buffer) + bufp->buffer;
                if (fixup_alt_jump)
                    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                if (laststart)
                    laststart = (laststart - old_buffer) + bufp->buffer;
                if (pending_exact)
                    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
            }
        } while (0);
    insert_op1(jump, laststart, (b + 3) - (laststart) - 3, b);
    b += 3;
} else {
    unsigned int nbytes = 10 + (upper_bound > 1) * 10;
    while (b - bufp->buffer + (nbytes) > bufp->allocated)
        do {
            unsigned char *old_buffer = bufp->buffer;
            if (bufp->allocated == (1L << 16))
                return REG_ESIZE;
            bufp->allocated <<= 1;
            if (bufp->allocated > (1L << 16))
                bufp->allocated = (1L << 16);
            bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
            if (bufp->buffer == ((void *)0))
                return REG_ESPACE;
            if (old_buffer != bufp->buffer) {
                b = (b - old_buffer) + bufp->buffer;
                begalt = (begalt - old_buffer) + bufp->buffer;
                if (fixup_alt_jump)
                    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                if (laststart)
                    laststart = (laststart - old_buffer) + bufp->buffer;
                if (pending_exact)
                    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
            }
        } while (0);
    insert_op2(succeed_n, laststart, (b + 5 + (upper_bound > 1) * 5) - (laststart) - 3, lower_bound, b);
    b += 5;
    insert_op2(set_number_at, laststart, 5, lower_bound, b);
    b += 5;
    if (upper_bound > 1) {
        store_op2(jump_n, b, (laststart + 5) - (b) - 3, upper_bound - 1);
        b += 5;
        insert_op2(set_number_at, laststart, b - laststart, upper_bound - 1, b);
        b += 5;
    }
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (upper_bound > 1) {
    store_op2(jump_n, b, (laststart + 5) - (b) - 3, upper_bound - 1);
    b += 5;
    insert_op2(set_number_at, laststart, b - laststart, upper_bound - 1, b);
    b += 5;
}
===================

if (p == pend)
    return REG_EEND;
===================

if (translate)
    c = translate[c];
===================

if (!(syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (p > pattern && p[-1] == '\\')
        goto normal_backslash;
}
===================

if (p > pattern && p[-1] == '\\')
    goto normal_backslash;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (syntax & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (c1 > regnum)
    return REG_ESUBREG;
===================

if (group_in_compile_stack(compile_stack, c1))
    goto normal_char;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (syntax & ((1) << 1))
    goto handle_plus;
else
    goto normal_backslash;
===================

if (!pending_exact || pending_exact + *pending_exact + 1 != b || *pending_exact == (1 << 8) - 1 || *p == '*' || *p == '^' || ((syntax & ((1) << 1)) ? *p == '\\' && (p[1] == '+' || p[1] == '?') : (*p == '+' || *p == '?')) || ((syntax & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && ((syntax & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) ? *p == '{' : (p[0] == '\\' && p[1] == '{')))) {
    laststart = b;
    do {
        while (b - bufp->buffer + (2) > bufp->allocated)
            do {
                unsigned char *old_buffer = bufp->buffer;
                if (bufp->allocated == (1L << 16))
                    return REG_ESIZE;
                bufp->allocated <<= 1;
                if (bufp->allocated > (1L << 16))
                    bufp->allocated = (1L << 16);
                bufp->buffer = (unsigned char *)realloc(bufp->buffer, bufp->allocated);
                if (bufp->buffer == ((void *)0))
                    return REG_ESPACE;
                if (old_buffer != bufp->buffer) {
                    b = (b - old_buffer) + bufp->buffer;
                    begalt = (begalt - old_buffer) + bufp->buffer;
                    if (fixup_alt_jump)
                        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
                    if (laststart)
                        laststart = (laststart - old_buffer) + bufp->buffer;
                    if (pending_exact)
                        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
                }
            } while (0);
        *b++ = (unsigned char)(exactn);
        *b++ = (unsigned char)(0);
    } while (0);
    pending_exact = b - 1;
}
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (bufp->allocated == (1L << 16))
    return REG_ESIZE;
===================

if (bufp->allocated > (1L << 16))
    bufp->allocated = (1L << 16);
===================

if (bufp->buffer == ((void *)0))
    return REG_ESPACE;
===================

if (old_buffer != bufp->buffer) {
    b = (b - old_buffer) + bufp->buffer;
    begalt = (begalt - old_buffer) + bufp->buffer;
    if (fixup_alt_jump)
        fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
    if (laststart)
        laststart = (laststart - old_buffer) + bufp->buffer;
    if (pending_exact)
        pending_exact = (pending_exact - old_buffer) + bufp->buffer;
}
===================

if (fixup_alt_jump)
    fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;
===================

if (laststart)
    laststart = (laststart - old_buffer) + bufp->buffer;
===================

if (pending_exact)
    pending_exact = (pending_exact - old_buffer) + bufp->buffer;
===================

if (fixup_alt_jump)
    store_op1(jump_past_alt, fixup_alt_jump, (b) - (fixup_alt_jump) - 3);
===================

if (!(compile_stack.avail == 0))
    return REG_EPAREN;
===================

function: store_op1
function: store_op2
function: insert_op1
function: insert_op2
function: at_begline_loc_p
function: at_endline_loc_p
function: group_in_compile_stack
if (compile_stack.stack[this_element].regnum == regnum)
    return 1;
===================

function: compile_range
if (p == pend)
    return REG_ERANGE;
===================

if (range_start > range_end)
    return syntax & (((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? REG_ERANGE : REG_NOERROR;
===================

function: re_compile_fastmap
if (fail_stack.stack == ((void *)0))
    return -2;
===================

if (p == pend) {
    bufp->can_be_null |= path_can_be_null;
    path_can_be_null = 1;
    p = fail_stack.stack[--fail_stack.avail];
}
===================

if (p[j / 8] & (1 << (j % 8)))
    fastmap[j] = 1;
===================

if (!(p[j / 8] & (1 << (j % 8))))
    fastmap[j] = 1;
===================

if (re_syntax_table[j] == 1)
    fastmap[j] = 1;
===================

if (re_syntax_table[j] != 1)
    fastmap[j] = 1;
===================

if (!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1)))
    fastmap['\n'] = 0;
else if (bufp->can_be_null)
    return 0;
===================

if (bufp->can_be_null)
    return 0;
===================

if (j > 0)
    continue;
===================

if ((re_opcode_t)*p != on_failure_jump && (re_opcode_t)*p != succeed_n)
    continue;
===================

if (!(fail_stack.avail == 0) && fail_stack.stack[fail_stack.avail - 1] == p)
    fail_stack.avail--;
===================

if (p + j < pend) {
    if (!(((fail_stack.avail == fail_stack.size) && !((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))) ? 0 : ((fail_stack).stack[(fail_stack).avail++] = p + j , 1)))
        return -2;
} else
    bufp->can_be_null = 1;
===================

if (!(((fail_stack.avail == fail_stack.size) && !((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1)))) ? 0 : ((fail_stack).stack[(fail_stack).avail++] = p + j , 1)))
    return -2;
===================

if (succeed_n_p) {
    do {
        do {
            (k) = *(p) & 255;
            (k) += ((signed char)(*((p) + 1))) << 8;
        } while (0);
        (p) += 2;
    } while (0);
    succeed_n_p = 0;
}
===================

if (k == 0) {
    p -= 4;
    succeed_n_p = 1;
    goto handle_on_failure_jump;
}
===================

function: re_set_registers
if (num_regs) {
    bufp->regs_allocated = 1;
    regs->num_regs = num_regs;
    regs->start = starts;
    regs->end = ends;
} else {
    bufp->regs_allocated = 0;
    regs->num_regs = 0;
    regs->start = regs->end = (regoff_t)0;
}
===================

function: re_search
function: re_search_2
if (startpos < 0 || startpos > total_size)
    return -1;
===================

if (endpos < -1)
    range = -1 - startpos;
else if (endpos > total_size)
    range = total_size - startpos;
===================

if (endpos > total_size)
    range = total_size - startpos;
===================

if (bufp->used > 0 && (re_opcode_t)bufp->buffer[0] == begbuf && range > 0) {
    if (startpos > 0)
        return -1;
    else
        range = 1;
}
===================

if (startpos > 0)
    return -1;
else
    range = 1;
===================

if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap(bufp) == -2)
        return -2;
===================

if (re_compile_fastmap(bufp) == -2)
    return -2;
===================

if (fastmap && startpos < total_size && !bufp->can_be_null) {
    if (range > 0) {
        register const char *d;
        register int lim = 0;
        int irange = range;
        if (startpos < size1 && startpos + range >= size1)
            lim = range - (size1 - startpos);
        d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
        if (translate)
            while (range > lim && !fastmap[(unsigned char)translate[(unsigned char)*d++]])
                range--;
        else
            while (range > lim && !fastmap[(unsigned char)*d++])
                range--;
        startpos += irange - range;
    } else {
        register char c = (size1 == 0 || startpos >= size1 ? string2[startpos - size1] : string1[startpos]);
        if (!fastmap[(unsigned char)(translate ? translate[(unsigned char)(c)] : (c))])
            goto advance;
    }
}
===================

if (range > 0) {
    register const char *d;
    register int lim = 0;
    int irange = range;
    if (startpos < size1 && startpos + range >= size1)
        lim = range - (size1 - startpos);
    d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
    if (translate)
        while (range > lim && !fastmap[(unsigned char)translate[(unsigned char)*d++]])
            range--;
    else
        while (range > lim && !fastmap[(unsigned char)*d++])
            range--;
    startpos += irange - range;
} else {
    register char c = (size1 == 0 || startpos >= size1 ? string2[startpos - size1] : string1[startpos]);
    if (!fastmap[(unsigned char)(translate ? translate[(unsigned char)(c)] : (c))])
        goto advance;
}
===================

if (startpos < size1 && startpos + range >= size1)
    lim = range - (size1 - startpos);
===================

if (translate)
    while (range > lim && !fastmap[(unsigned char)translate[(unsigned char)*d++]])
        range--;
else
    while (range > lim && !fastmap[(unsigned char)*d++])
        range--;
===================

if (!fastmap[(unsigned char)(translate ? translate[(unsigned char)(c)] : (c))])
    goto advance;
===================

if (range >= 0 && startpos == total_size && fastmap && !bufp->can_be_null)
    return -1;
===================

if (val >= 0)
    return startpos;
===================

if (val == -2)
    return -2;
===================

if (!range)
    break;
else if (range > 0) {
    range--;
    startpos++;
} else {
    range++;
    startpos--;
}
===================

if (range > 0) {
    range--;
    startpos++;
} else {
    range++;
    startpos--;
}
===================

function: re_match
function: re_match_2
if (fail_stack.stack == ((void *)0))
    return -2;
===================

if (bufp->re_nsub) {
    regstart = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    regend = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    old_regstart = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    old_regend = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    best_regstart = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    best_regend = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    reg_info = ((register_info_type *)__builtin_alloca((num_regs) * sizeof(register_info_type)));
    reg_dummy = ((const char **)__builtin_alloca((num_regs) * sizeof(const char *)));
    reg_info_dummy = ((register_info_type *)__builtin_alloca((num_regs) * sizeof(register_info_type)));
    if (!(regstart && regend && old_regstart && old_regend && reg_info && best_regstart && best_regend && reg_dummy && reg_info_dummy)) {
        __builtin_alloca(0);
        return -2;
    }
}
===================

if (!(regstart && regend && old_regstart && old_regend && reg_info && best_regstart && best_regend && reg_dummy && reg_info_dummy)) {
    __builtin_alloca(0);
    return -2;
}
===================

if (pos < 0 || pos > size1 + size2) {
    __builtin_alloca(0);
    return -1;
}
===================

if (size2 == 0 && string1 != ((void *)0)) {
    string2 = string1;
    size2 = size1;
    string1 = 0;
    size1 = 0;
}
===================

if (stop <= size1) {
    end_match_1 = string1 + stop;
    end_match_2 = string2;
} else {
    end_match_1 = end1;
    end_match_2 = string2 + stop - size1;
}
===================

if (size1 > 0 && pos <= size1) {
    d = string1 + pos;
    dend = end_match_1;
} else {
    d = string2 + pos - size1;
    dend = end_match_2;
}
===================

if (p == pend) {
    ;
    if (d != end_match_2) {
        ;
        if (!(fail_stack.avail == 0)) {
            boolean same_str_p = ((size1 && string1 <= (match_end) && (match_end) <= string1 + size1) == (dend == end_match_1));
            if (!best_regs_set || (same_str_p && d > match_end) || (!same_str_p && !(dend == end_match_1))) {
                best_regs_set = 1;
                match_end = d;
                ;
                for (mcnt = 1; mcnt < num_regs; mcnt++) {
                    best_regstart[mcnt] = regstart[mcnt];
                    best_regend[mcnt] = regend[mcnt];
                }
            }
            goto fail;
        } else if (best_regs_set) {
          restore_best_regs:
            ;
            d = match_end;
            dend = ((d >= string1 && d <= end1) ? end_match_1 : end_match_2);
            for (mcnt = 1; mcnt < num_regs; mcnt++) {
                regstart[mcnt] = best_regstart[mcnt];
                regend[mcnt] = best_regend[mcnt];
            }
        }
    }
    ;
    if (regs && !bufp->no_sub) {
        if (bufp->regs_allocated == 0) {
            regs->num_regs = ((30) > (num_regs + 1) ? (30) : (num_regs + 1));
            regs->start = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
            regs->end = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
            if (regs->start == ((void *)0) || regs->end == ((void *)0))
                return -2;
            bufp->regs_allocated = 1;
        } else if (bufp->regs_allocated == 1) {
            if (regs->num_regs < num_regs + 1) {
                regs->num_regs = num_regs + 1;
                ((regs->start) = (regoff_t *)realloc(regs->start, (regs->num_regs) * sizeof(regoff_t)));
                ((regs->end) = (regoff_t *)realloc(regs->end, (regs->num_regs) * sizeof(regoff_t)));
                if (regs->start == ((void *)0) || regs->end == ((void *)0))
                    return -2;
            }
        } else {
            ;
        }
        if (regs->num_regs > 0) {
            regs->start[0] = pos;
            regs->end[0] = ((dend == end_match_1) ? d - string1 : d - string2 + size1);
        }
        for (mcnt = 1; mcnt < ((num_regs) < (regs->num_regs) ? (num_regs) : (regs->num_regs)); mcnt++) {
            if (((regstart[mcnt]) == ((char *)-1)) || ((regend[mcnt]) == ((char *)-1)))
                regs->start[mcnt] = regs->end[mcnt] = -1;
            else {
                regs->start[mcnt] = ((size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1) ? (regstart[mcnt]) - string1 : (regstart[mcnt]) - string2 + size1);
                regs->end[mcnt] = ((size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1) ? (regend[mcnt]) - string1 : (regend[mcnt]) - string2 + size1);
            }
        }
        for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
            regs->start[mcnt] = regs->end[mcnt] = -1;
    }
    __builtin_alloca(0);
    ;
    ;
    mcnt = d - pos - ((dend == end_match_1) ? string1 : string2 - size1);
    ;
    return mcnt;
}
===================

if (d != end_match_2) {
    ;
    if (!(fail_stack.avail == 0)) {
        boolean same_str_p = ((size1 && string1 <= (match_end) && (match_end) <= string1 + size1) == (dend == end_match_1));
        if (!best_regs_set || (same_str_p && d > match_end) || (!same_str_p && !(dend == end_match_1))) {
            best_regs_set = 1;
            match_end = d;
            ;
            for (mcnt = 1; mcnt < num_regs; mcnt++) {
                best_regstart[mcnt] = regstart[mcnt];
                best_regend[mcnt] = regend[mcnt];
            }
        }
        goto fail;
    } else if (best_regs_set) {
      restore_best_regs:
        ;
        d = match_end;
        dend = ((d >= string1 && d <= end1) ? end_match_1 : end_match_2);
        for (mcnt = 1; mcnt < num_regs; mcnt++) {
            regstart[mcnt] = best_regstart[mcnt];
            regend[mcnt] = best_regend[mcnt];
        }
    }
}
===================

if (!(fail_stack.avail == 0)) {
    boolean same_str_p = ((size1 && string1 <= (match_end) && (match_end) <= string1 + size1) == (dend == end_match_1));
    if (!best_regs_set || (same_str_p && d > match_end) || (!same_str_p && !(dend == end_match_1))) {
        best_regs_set = 1;
        match_end = d;
        ;
        for (mcnt = 1; mcnt < num_regs; mcnt++) {
            best_regstart[mcnt] = regstart[mcnt];
            best_regend[mcnt] = regend[mcnt];
        }
    }
    goto fail;
} else if (best_regs_set) {
  restore_best_regs:
    ;
    d = match_end;
    dend = ((d >= string1 && d <= end1) ? end_match_1 : end_match_2);
    for (mcnt = 1; mcnt < num_regs; mcnt++) {
        regstart[mcnt] = best_regstart[mcnt];
        regend[mcnt] = best_regend[mcnt];
    }
}
===================

if (!best_regs_set || (same_str_p && d > match_end) || (!same_str_p && !(dend == end_match_1))) {
    best_regs_set = 1;
    match_end = d;
    ;
    for (mcnt = 1; mcnt < num_regs; mcnt++) {
        best_regstart[mcnt] = regstart[mcnt];
        best_regend[mcnt] = regend[mcnt];
    }
}
===================

if (best_regs_set) {
  restore_best_regs:
    ;
    d = match_end;
    dend = ((d >= string1 && d <= end1) ? end_match_1 : end_match_2);
    for (mcnt = 1; mcnt < num_regs; mcnt++) {
        regstart[mcnt] = best_regstart[mcnt];
        regend[mcnt] = best_regend[mcnt];
    }
}
===================

if (regs && !bufp->no_sub) {
    if (bufp->regs_allocated == 0) {
        regs->num_regs = ((30) > (num_regs + 1) ? (30) : (num_regs + 1));
        regs->start = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
        regs->end = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
        if (regs->start == ((void *)0) || regs->end == ((void *)0))
            return -2;
        bufp->regs_allocated = 1;
    } else if (bufp->regs_allocated == 1) {
        if (regs->num_regs < num_regs + 1) {
            regs->num_regs = num_regs + 1;
            ((regs->start) = (regoff_t *)realloc(regs->start, (regs->num_regs) * sizeof(regoff_t)));
            ((regs->end) = (regoff_t *)realloc(regs->end, (regs->num_regs) * sizeof(regoff_t)));
            if (regs->start == ((void *)0) || regs->end == ((void *)0))
                return -2;
        }
    } else {
        ;
    }
    if (regs->num_regs > 0) {
        regs->start[0] = pos;
        regs->end[0] = ((dend == end_match_1) ? d - string1 : d - string2 + size1);
    }
    for (mcnt = 1; mcnt < ((num_regs) < (regs->num_regs) ? (num_regs) : (regs->num_regs)); mcnt++) {
        if (((regstart[mcnt]) == ((char *)-1)) || ((regend[mcnt]) == ((char *)-1)))
            regs->start[mcnt] = regs->end[mcnt] = -1;
        else {
            regs->start[mcnt] = ((size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1) ? (regstart[mcnt]) - string1 : (regstart[mcnt]) - string2 + size1);
            regs->end[mcnt] = ((size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1) ? (regend[mcnt]) - string1 : (regend[mcnt]) - string2 + size1);
        }
    }
    for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
        regs->start[mcnt] = regs->end[mcnt] = -1;
}
===================

if (bufp->regs_allocated == 0) {
    regs->num_regs = ((30) > (num_regs + 1) ? (30) : (num_regs + 1));
    regs->start = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
    regs->end = ((regoff_t *)malloc((regs->num_regs) * sizeof(regoff_t)));
    if (regs->start == ((void *)0) || regs->end == ((void *)0))
        return -2;
    bufp->regs_allocated = 1;
} else if (bufp->regs_allocated == 1) {
    if (regs->num_regs < num_regs + 1) {
        regs->num_regs = num_regs + 1;
        ((regs->start) = (regoff_t *)realloc(regs->start, (regs->num_regs) * sizeof(regoff_t)));
        ((regs->end) = (regoff_t *)realloc(regs->end, (regs->num_regs) * sizeof(regoff_t)));
        if (regs->start == ((void *)0) || regs->end == ((void *)0))
            return -2;
    }
} else {
    ;
}
===================

if (regs->start == ((void *)0) || regs->end == ((void *)0))
    return -2;
===================

if (bufp->regs_allocated == 1) {
    if (regs->num_regs < num_regs + 1) {
        regs->num_regs = num_regs + 1;
        ((regs->start) = (regoff_t *)realloc(regs->start, (regs->num_regs) * sizeof(regoff_t)));
        ((regs->end) = (regoff_t *)realloc(regs->end, (regs->num_regs) * sizeof(regoff_t)));
        if (regs->start == ((void *)0) || regs->end == ((void *)0))
            return -2;
    }
} else {
    ;
}
===================

if (regs->num_regs < num_regs + 1) {
    regs->num_regs = num_regs + 1;
    ((regs->start) = (regoff_t *)realloc(regs->start, (regs->num_regs) * sizeof(regoff_t)));
    ((regs->end) = (regoff_t *)realloc(regs->end, (regs->num_regs) * sizeof(regoff_t)));
    if (regs->start == ((void *)0) || regs->end == ((void *)0))
        return -2;
}
===================

if (regs->start == ((void *)0) || regs->end == ((void *)0))
    return -2;
===================

if (regs->num_regs > 0) {
    regs->start[0] = pos;
    regs->end[0] = ((dend == end_match_1) ? d - string1 : d - string2 + size1);
}
===================

if (((regstart[mcnt]) == ((char *)-1)) || ((regend[mcnt]) == ((char *)-1)))
    regs->start[mcnt] = regs->end[mcnt] = -1;
else {
    regs->start[mcnt] = ((size1 && string1 <= (regstart[mcnt]) && (regstart[mcnt]) <= string1 + size1) ? (regstart[mcnt]) - string1 : (regstart[mcnt]) - string2 + size1);
    regs->end[mcnt] = ((size1 && string1 <= (regend[mcnt]) && (regend[mcnt]) <= string1 + size1) ? (regend[mcnt]) - string1 : (regend[mcnt]) - string2 + size1);
}
===================

if (translate) {
    do {
        while (d == dend)
            {
                if (dend == end_match_2)
                    goto fail;
                d = string2;
                dend = end_match_2;
            }
        ;
        if (translate[(unsigned char)*d++] != (char)*p++)
            goto fail;
    } while (--mcnt);
} else {
    do {
        while (d == dend)
            {
                if (dend == end_match_2)
                    goto fail;
                d = string2;
                dend = end_match_2;
            }
        ;
        if (*d++ != (char)*p++)
            goto fail;
    } while (--mcnt);
}
===================

if (dend == end_match_2)
    goto fail;
===================

if (translate[(unsigned char)*d++] != (char)*p++)
    goto fail;
===================

if (dend == end_match_2)
    goto fail;
===================

if (*d++ != (char)*p++)
    goto fail;
===================

if (dend == end_match_2)
    goto fail;
===================

if ((!(bufp->syntax & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1)) && (translate ? translate[(unsigned char)(*d)] : (*d)) == '\n') || (bufp->syntax & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) && (translate ? translate[(unsigned char)(*d)] : (*d)) == '\x00'))
    goto fail;
===================

if (dend == end_match_2)
    goto fail;
===================

if (c < (unsigned int)(*p * 8) && p[1 + c / 8] & (1 << (c % 8)))
    not = !not;
===================

if (!not)
    goto fail;
===================

if (((reg_info[*p]).bits.match_null_string_p) == 3)
    ((reg_info[*p]).bits.match_null_string_p) = group_match_null_string_p(&p1, pend, reg_info);
===================

if (lowest_active_reg == ((1 << 8) + 1))
    lowest_active_reg = *p;
===================

if (lowest_active_reg == highest_active_reg) {
    lowest_active_reg = ((1 << 8) + 1);
    highest_active_reg = (1 << 8);
} else {
    unsigned char r = *p - 1;
    while (r > 0 && !((reg_info[r]).bits.is_active))
        r--;
    if (r == 0) {
        lowest_active_reg = ((1 << 8) + 1);
        highest_active_reg = (1 << 8);
    } else
        highest_active_reg = r;
}
===================

if (r == 0) {
    lowest_active_reg = ((1 << 8) + 1);
    highest_active_reg = (1 << 8);
} else
    highest_active_reg = r;
===================

if ((!((reg_info[*p]).bits.matched_something) || (re_opcode_t)p[-3] == start_memory) && (p + 2) < pend) {
    boolean is_a_jump_n = 0;
    p1 = p + 2;
    mcnt = 0;
    switch ((re_opcode_t)*p1++) {
      case jump_n:
        is_a_jump_n = 1;
      case pop_failure_jump:
      case maybe_pop_jump:
      case jump:
      case dummy_failure_jump:
        do {
            do {
                (mcnt) = *(p1) & 255;
                (mcnt) += ((signed char)(*((p1) + 1))) << 8;
            } while (0);
            (p1) += 2;
        } while (0);
        if (is_a_jump_n)
            p1 += 2;
        break;
      default:
        ;
    }
    p1 += mcnt;
    if (mcnt < 0 && (re_opcode_t)*p1 == on_failure_jump && (re_opcode_t)p1[3] == start_memory && p1[4] == *p) {
        if (((reg_info[*p]).bits.ever_matched_something)) {
            unsigned int r;
            ((reg_info[*p]).bits.ever_matched_something) = 0;
            for (r = *p; r < *p + *(p + 1); r++) {
                regstart[r] = old_regstart[r];
                if ((int)old_regend[r] >= (int)regstart[r])
                    regend[r] = old_regend[r];
            }
        }
        p1++;
        do {
            do {
                (mcnt) = *(p1) & 255;
                (mcnt) += ((signed char)(*((p1) + 1))) << 8;
            } while (0);
            (p1) += 2;
        } while (0);
        do {
            char *destination;
            int this_reg;
            ;
            ;
            ;
            ;
            ;
            ;
            ;
            while (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4))
                {
                    if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
                        return -2;
                    ;
                    ;
                }
            ;
            for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; this_reg++) {
                ;
                ;
                ;
                fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)regstart[this_reg];
                ;
                fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)regend[this_reg];
                ;
                ;
                ;
                ;
                ;
                ;
                fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)reg_info[this_reg].word;
            }
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)lowest_active_reg;
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)highest_active_reg;
            ;
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)p1 + mcnt;
            ;
            ;
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)d;
            ;
            ;
        } while (0);
        goto fail;
    }
}
===================

if (is_a_jump_n)
    p1 += 2;
===================

if (mcnt < 0 && (re_opcode_t)*p1 == on_failure_jump && (re_opcode_t)p1[3] == start_memory && p1[4] == *p) {
    if (((reg_info[*p]).bits.ever_matched_something)) {
        unsigned int r;
        ((reg_info[*p]).bits.ever_matched_something) = 0;
        for (r = *p; r < *p + *(p + 1); r++) {
            regstart[r] = old_regstart[r];
            if ((int)old_regend[r] >= (int)regstart[r])
                regend[r] = old_regend[r];
        }
    }
    p1++;
    do {
        do {
            (mcnt) = *(p1) & 255;
            (mcnt) += ((signed char)(*((p1) + 1))) << 8;
        } while (0);
        (p1) += 2;
    } while (0);
    do {
        char *destination;
        int this_reg;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        while (((fail_stack).size - (fail_stack).avail) < ((highest_active_reg - lowest_active_reg + 1) * 3 + 4))
            {
                if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
                    return -2;
                ;
                ;
            }
        ;
        for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; this_reg++) {
            ;
            ;
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)regstart[this_reg];
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)regend[this_reg];
            ;
            ;
            ;
            ;
            ;
            ;
            fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)reg_info[this_reg].word;
        }
        ;
        fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)lowest_active_reg;
        ;
        fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)highest_active_reg;
        ;
        ;
        fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)p1 + mcnt;
        ;
        ;
        ;
        fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t)d;
        ;
        ;
    } while (0);
    goto fail;
}
===================

if (((reg_info[*p]).bits.ever_matched_something)) {
    unsigned int r;
    ((reg_info[*p]).bits.ever_matched_something) = 0;
    for (r = *p; r < *p + *(p + 1); r++) {
        regstart[r] = old_regstart[r];
        if ((int)old_regend[r] >= (int)regstart[r])
            regend[r] = old_regend[r];
    }
}
===================

if ((int)old_regend[r] >= (int)regstart[r])
    regend[r] = old_regend[r];
===================

if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
    return -2;
===================

if (((regstart[regno]) == ((char *)-1)) || ((regend[regno]) == ((char *)-1)))
    goto fail;
===================

if (dend2 == end_match_2)
    break;
===================

if (dend2 == regend[regno])
    break;
===================

if (d2 == dend2)
    break;
===================

if (dend == end_match_2)
    goto fail;
===================

if (mcnt > dend2 - d2)
    mcnt = dend2 - d2;
===================

if (translate ? bcmp_translate(d, d2, mcnt, translate) : memcmp((d), (d2), (mcnt)))
    goto fail;
===================

if (((d) == (size1 ? string1 : string2) || !size2)) {
    if (!bufp->not_bol)
        break;
} else if (d[-1] == '\n' && bufp->newline_anchor) {
    break;
}
===================

if (!bufp->not_bol)
    break;
===================

if (d[-1] == '\n' && bufp->newline_anchor) {
    break;
}
===================

if (((d) == end2)) {
    if (!bufp->not_eol)
        break;
} else if ((d == end1 ? *string2 : *d) == '\n' && bufp->newline_anchor) {
    break;
}
===================

if (!bufp->not_eol)
    break;
===================

if ((d == end1 ? *string2 : *d) == '\n' && bufp->newline_anchor) {
    break;
}
===================

if (((d) == (size1 ? string1 : string2) || !size2))
    break;
===================

if (((d) == end2))
    break;
===================

if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
    return -2;
===================

if (p1 < pend && (re_opcode_t)*p1 == start_memory) {
    highest_active_reg = *(p1 + 1) + *(p1 + 2);
    if (lowest_active_reg == ((1 << 8) + 1))
        lowest_active_reg = *(p1 + 1);
}
===================

if (lowest_active_reg == ((1 << 8) + 1))
    lowest_active_reg = *(p1 + 1);
===================

if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
    return -2;
===================

if (p2 == pend) {
    p[-3] = (unsigned char)pop_failure_jump;
    ;
} else if ((re_opcode_t)*p2 == exactn || (bufp->newline_anchor && (re_opcode_t)*p2 == endline)) {
    register unsigned char c = *p2 == (unsigned char)endline ? '\n' : p2[2];
    p1 = p + mcnt;
    if ((re_opcode_t)p1[3] == exactn && p1[5] != c) {
        p[-3] = (unsigned char)pop_failure_jump;
        ;
    } else if ((re_opcode_t)p1[3] == charset || (re_opcode_t)p1[3] == charset_not) {
        int not = (re_opcode_t)p1[3] == charset_not;
        if (c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8)))
            not = !not;
        if (!not) {
            p[-3] = (unsigned char)pop_failure_jump;
            ;
        }
    }
}
===================

if ((re_opcode_t)*p2 == exactn || (bufp->newline_anchor && (re_opcode_t)*p2 == endline)) {
    register unsigned char c = *p2 == (unsigned char)endline ? '\n' : p2[2];
    p1 = p + mcnt;
    if ((re_opcode_t)p1[3] == exactn && p1[5] != c) {
        p[-3] = (unsigned char)pop_failure_jump;
        ;
    } else if ((re_opcode_t)p1[3] == charset || (re_opcode_t)p1[3] == charset_not) {
        int not = (re_opcode_t)p1[3] == charset_not;
        if (c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8)))
            not = !not;
        if (!not) {
            p[-3] = (unsigned char)pop_failure_jump;
            ;
        }
    }
}
===================

if ((re_opcode_t)p1[3] == exactn && p1[5] != c) {
    p[-3] = (unsigned char)pop_failure_jump;
    ;
} else if ((re_opcode_t)p1[3] == charset || (re_opcode_t)p1[3] == charset_not) {
    int not = (re_opcode_t)p1[3] == charset_not;
    if (c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8)))
        not = !not;
    if (!not) {
        p[-3] = (unsigned char)pop_failure_jump;
        ;
    }
}
===================

if ((re_opcode_t)p1[3] == charset || (re_opcode_t)p1[3] == charset_not) {
    int not = (re_opcode_t)p1[3] == charset_not;
    if (c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8)))
        not = !not;
    if (!not) {
        p[-3] = (unsigned char)pop_failure_jump;
        ;
    }
}
===================

if (c < (unsigned char)(p1[4] * 8) && p1[5 + c / 8] & (1 << (c % 8)))
    not = !not;
===================

if (!not) {
    p[-3] = (unsigned char)pop_failure_jump;
    ;
}
===================

if ((re_opcode_t)p[-1] != pop_failure_jump) {
    p[-1] = (unsigned char)jump;
    ;
    goto unconditional_jump;
}
===================

if (string_temp != ((void *)0))
    sdummy = (const char *)string_temp;
===================

if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
    return -2;
===================

if (!((fail_stack).size > re_max_failures * ((num_regs - 1) * 3 + 4) ? 0 : ((fail_stack).stack = (fail_stack_elt_t *)(destination = (char *)__builtin_alloca(((fail_stack).size << 1) * sizeof(fail_stack_elt_t)) , memcpy((destination), ((fail_stack).stack), ((fail_stack).size * sizeof(fail_stack_elt_t))) , destination) , (fail_stack).stack == ((void *)0) ? 0 : ((fail_stack).size <<= 1 , 1))))
    return -2;
===================

if (mcnt > 0) {
    mcnt--;
    p += 2;
    do {
        do {
            (p)[0] = (mcnt) & 255;
            (p)[1] = (mcnt) >> 8;
        } while (0);
        (p) += 2;
    } while (0);
    ;
} else if (mcnt == 0) {
    ;
    p[2] = (unsigned char)no_op;
    p[3] = (unsigned char)no_op;
    goto on_failure;
}
===================

if (mcnt == 0) {
    ;
    p[2] = (unsigned char)no_op;
    p[3] = (unsigned char)no_op;
    goto on_failure;
}
===================

if (mcnt) {
    mcnt--;
    do {
        (p + 2)[0] = (mcnt) & 255;
        (p + 2)[1] = (mcnt) >> 8;
    } while (0);
    goto unconditional_jump;
} else
    p += 4;
===================

if ((((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1)))
    break;
===================

if ((((d) == (size1 ? string1 : string2) || !size2) || ((d) == end2) || (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) != (re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1)))
    goto fail;
===================

if ((re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1) && (((d) == (size1 ? string1 : string2) || !size2) || !(re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1)))
    break;
===================

if (!((d) == (size1 ? string1 : string2) || !size2) && (re_syntax_table[(d - 1) == end1 ? *string2 : (d - 1) == string2 - 1 ? *(end1 - 1) : *(d - 1)] == 1) && (!(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1) || ((d) == end2)))
    break;
===================

if (dend == end_match_2)
    goto fail;
===================

if (!(re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1))
    goto fail;
===================

if (dend == end_match_2)
    goto fail;
===================

if ((re_syntax_table[(d) == end1 ? *string2 : (d) == string2 - 1 ? *(end1 - 1) : *(d)] == 1))
    goto fail;
===================

if (!(fail_stack.avail == 0)) {
    ;
    {
        int this_reg;
        const unsigned char *string_temp;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        string_temp = fail_stack.stack[--fail_stack.avail];
        if (string_temp != ((void *)0))
            d = (const char *)string_temp;
        ;
        ;
        ;
        p = (unsigned char *)fail_stack.stack[--fail_stack.avail];
        ;
        ;
        highest_active_reg = (unsigned int)fail_stack.stack[--fail_stack.avail];
        ;
        lowest_active_reg = (unsigned int)fail_stack.stack[--fail_stack.avail];
        ;
        for (this_reg = highest_active_reg; this_reg >= lowest_active_reg; this_reg--) {
            ;
            reg_info[this_reg].word = fail_stack.stack[--fail_stack.avail];
            ;
            regend[this_reg] = (const char *)fail_stack.stack[--fail_stack.avail];
            ;
            regstart[this_reg] = (const char *)fail_stack.stack[--fail_stack.avail];
            ;
        }
        ;
    }
    ;
    if (!p)
        goto fail;
    ;
    if (p < pend) {
        boolean is_a_jump_n = 0;
        switch ((re_opcode_t)*p) {
          case jump_n:
            is_a_jump_n = 1;
          case maybe_pop_jump:
          case pop_failure_jump:
          case jump:
            p1 = p + 1;
            do {
                do {
                    (mcnt) = *(p1) & 255;
                    (mcnt) += ((signed char)(*((p1) + 1))) << 8;
                } while (0);
                (p1) += 2;
            } while (0);
            p1 += mcnt;
            if ((is_a_jump_n && (re_opcode_t)*p1 == succeed_n) || (!is_a_jump_n && (re_opcode_t)*p1 == on_failure_jump))
                goto fail;
            break;
          default:
            ;
        }
    }
    if (d >= string1 && d <= end1)
        dend = end_match_1;
} else
    break;
===================

if (string_temp != ((void *)0))
    d = (const char *)string_temp;
===================

if (!p)
    goto fail;
===================

if (p < pend) {
    boolean is_a_jump_n = 0;
    switch ((re_opcode_t)*p) {
      case jump_n:
        is_a_jump_n = 1;
      case maybe_pop_jump:
      case pop_failure_jump:
      case jump:
        p1 = p + 1;
        do {
            do {
                (mcnt) = *(p1) & 255;
                (mcnt) += ((signed char)(*((p1) + 1))) << 8;
            } while (0);
            (p1) += 2;
        } while (0);
        p1 += mcnt;
        if ((is_a_jump_n && (re_opcode_t)*p1 == succeed_n) || (!is_a_jump_n && (re_opcode_t)*p1 == on_failure_jump))
            goto fail;
        break;
      default:
        ;
    }
}
===================

if ((is_a_jump_n && (re_opcode_t)*p1 == succeed_n) || (!is_a_jump_n && (re_opcode_t)*p1 == on_failure_jump))
    goto fail;
===================

if (d >= string1 && d <= end1)
    dend = end_match_1;
===================

if (best_regs_set)
    goto restore_best_regs;
===================

function: group_match_null_string_p
if (mcnt >= 0) {
    while ((re_opcode_t)p1[mcnt - 3] == jump_past_alt)
        {
            if (!alt_match_null_string_p(p1, p1 + mcnt - 3, reg_info))
                return 0;
            p1 += mcnt;
            if ((re_opcode_t)*p1 != on_failure_jump)
                break;
            p1++;
            do {
                do {
                    (mcnt) = *(p1) & 255;
                    (mcnt) += ((signed char)(*((p1) + 1))) << 8;
                } while (0);
                (p1) += 2;
            } while (0);
            if ((re_opcode_t)p1[mcnt - 3] != jump_past_alt) {
                p1 -= 3;
                break;
            }
        }
    do {
        (mcnt) = *(p1 - 2) & 255;
        (mcnt) += ((signed char)(*((p1 - 2) + 1))) << 8;
    } while (0);
    if (!alt_match_null_string_p(p1, p1 + mcnt, reg_info))
        return 0;
    p1 += mcnt;
}
===================

if (!alt_match_null_string_p(p1, p1 + mcnt - 3, reg_info))
    return 0;
===================

if ((re_opcode_t)*p1 != on_failure_jump)
    break;
===================

if ((re_opcode_t)p1[mcnt - 3] != jump_past_alt) {
    p1 -= 3;
    break;
}
===================

if (!alt_match_null_string_p(p1, p1 + mcnt, reg_info))
    return 0;
===================

if (!common_op_match_null_string_p(&p1, end, reg_info))
    return 0;
===================

function: alt_match_null_string_p
if (!common_op_match_null_string_p(&p1, end, reg_info))
    return 0;
===================

function: common_op_match_null_string_p
if (((reg_info[reg_no]).bits.match_null_string_p) == 3)
    ((reg_info[reg_no]).bits.match_null_string_p) = ret;
===================

if (!ret)
    return 0;
===================

if (mcnt >= 0)
    p1 += mcnt;
else
    return 0;
===================

if (mcnt == 0) {
    p1 -= 4;
    do {
        do {
            (mcnt) = *(p1) & 255;
            (mcnt) += ((signed char)(*((p1) + 1))) << 8;
        } while (0);
        (p1) += 2;
    } while (0);
    p1 += mcnt;
} else
    return 0;
===================

if (!((reg_info[*p1]).bits.match_null_string_p))
    return 0;
===================

function: bcmp_translate
if (translate[*p1++] != translate[*p2++])
    return 1;
===================

function: re_compile_pattern
function: regcomp
if (cflags & (1 << 1)) {
    unsigned int i;
    preg->translate = (char *)malloc(256);
    if (preg->translate == ((void *)0))
        return (int)REG_ESPACE;
    for (i = 0; i < 256; i++)
        preg->translate[i] = (1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? tolower(i) : i;
} else
    preg->translate = ((void *)0);
===================

if (preg->translate == ((void *)0))
    return (int)REG_ESPACE;
===================

if (cflags & ((1 << 1) << 1)) {
    syntax &= ~(((((((1) << 1) << 1) << 1) << 1) << 1) << 1);
    syntax |= (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
    preg->newline_anchor = 1;
} else
    preg->newline_anchor = 0;
===================

if (ret == REG_ERPAREN)
    ret = REG_EPAREN;
===================

function: regexec
if (want_reg_info) {
    regs.num_regs = nmatch;
    regs.start = ((regoff_t *)malloc((nmatch) * sizeof(regoff_t)));
    regs.end = ((regoff_t *)malloc((nmatch) * sizeof(regoff_t)));
    if (regs.start == ((void *)0) || regs.end == ((void *)0))
        return (int)REG_NOMATCH;
}
===================

if (regs.start == ((void *)0) || regs.end == ((void *)0))
    return (int)REG_NOMATCH;
===================

if (want_reg_info) {
    if (ret >= 0) {
        unsigned int r;
        for (r = 0; r < nmatch; r++) {
            pmatch[r].rm_so = regs.start[r];
            pmatch[r].rm_eo = regs.end[r];
        }
    }
    free(regs.start);
    free(regs.end);
}
===================

if (ret >= 0) {
    unsigned int r;
    for (r = 0; r < nmatch; r++) {
        pmatch[r].rm_so = regs.start[r];
        pmatch[r].rm_eo = regs.end[r];
    }
}
===================

function: regerror
if (errcode < 0 || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
    abort();
===================

if (!msg)
    msg = "Success";
===================

if (errbuf_size != 0) {
    if (msg_size > errbuf_size) {
        strncpy(errbuf, msg, errbuf_size - 1);
        errbuf[errbuf_size - 1] = 0;
    } else
        strcpy(errbuf, msg);
}
===================

if (msg_size > errbuf_size) {
    strncpy(errbuf, msg, errbuf_size - 1);
    errbuf[errbuf_size - 1] = 0;
} else
    strcpy(errbuf, msg);
===================

function: regfree
if (preg->buffer != ((void *)0))
    free(preg->buffer);
===================

if (preg->fastmap != ((void *)0))
    free(preg->fastmap);
===================

if (preg->translate != ((void *)0))
    free(preg->translate);
===================

function: xcalloc
if (!r)
    dfaerror("Memory exhausted");
===================

function: xmalloc_1
if (!r)
    dfaerror("Memory exhausted");
===================

function: xrealloc_1
if (!r)
    dfaerror("Memory exhausted");
===================

function: tstbit
function: setbit
function: clrbit
function: copyset
function: zeroset
function: notset
function: equal
if (s1[i] != s2[i])
    return 0;
===================

function: charclass_index
if (equal(s, dfa->charclasses[i]))
    return i;
===================

if ((dfa->cindex) >= (dfa->calloc)) {
    while ((dfa->cindex) >= (dfa->calloc))
        (dfa->calloc) *= 2;
    ((dfa->charclasses) = (charclass *)xrealloc_1((ptr_t)(dfa->charclasses), (dfa->calloc) * sizeof(charclass)));
}
===================

function: dfasyntax
function: is_alpha
function: is_upper
function: is_lower
function: is_digit
function: is_xdigit
function: is_space
function: is_punct
function: is_alnum
function: is_print
function: is_graph
function: is_cntrl
function: looking_at
if (lexleft < len)
    return 0;
===================

function: lex
if (!lexleft)
    if (0 != 0)
        dfaerror(0);
    else
        return END;
===================

if (0 != 0)
    dfaerror(0);
else
    return END;
===================

if (backslash)
    goto normal_char;
===================

if (lexleft == 0)
    dfaerror("Unfinished \\ escape");
===================

if (backslash)
    goto normal_char;
===================

if (syntax_bits & ((((1) << 1) << 1) << 1) || lasttok == END || lasttok == LPAREN || lasttok == OR)
    return lasttok = BEGLINE;
===================

if (backslash)
    goto normal_char;
===================

if (syntax_bits & ((((1) << 1) << 1) << 1) || lexleft == 0 || (syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == ')' : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')') || (syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) ? lexleft > 0 && *lexptr == '|' : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|') || ((syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) && lexleft > 0 && *lexptr == '\n'))
    return lasttok = ENDLINE;
===================

if (backslash && !(syntax_bits & (((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    laststart = 0;
    return lasttok = BACKREF;
}
===================

if (backslash)
    return lasttok = BEGWORD;
===================

if (backslash)
    return lasttok = ENDWORD;
===================

if (backslash)
    return lasttok = LIMWORD;
===================

if (backslash)
    return lasttok = NOTLIMWORD;
===================

if (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (backslash != ((syntax_bits & ((1) << 1)) != 0))
    goto normal_char;
===================

if (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart)
    goto normal_char;
===================

if (backslash)
    goto normal_char;
===================

if (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart)
    goto normal_char;
===================

if (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (backslash != ((syntax_bits & ((1) << 1)) != 0))
    goto normal_char;
===================

if (!(syntax_bits & (((((1) << 1) << 1) << 1) << 1)) && laststart)
    goto normal_char;
===================

if (!(syntax_bits & ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
    goto normal_char;
===================

if (backslash != ((syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
    goto normal_char;
===================

if (!lexleft)
    if ("unfinished repeat count" != 0)
        dfaerror("unfinished repeat count");
    else
        return END;
===================

if ("unfinished repeat count" != 0)
    dfaerror("unfinished repeat count");
else
    return END;
===================

if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit))) {
    minrep = c - '0';
    for (;;) {
        {
            if (!lexleft)
                if ("unfinished repeat count" != 0)
                    dfaerror("unfinished repeat count");
                else
                    return END;
            (c) = (unsigned char)*lexptr++;
            --lexleft;
        }
        ;
        if (!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
            break;
        minrep = 10 * minrep + c - '0';
    }
} else if (c != ',')
    dfaerror("malformed repeat count");
===================

if (!lexleft)
    if ("unfinished repeat count" != 0)
        dfaerror("unfinished repeat count");
    else
        return END;
===================

if ("unfinished repeat count" != 0)
    dfaerror("unfinished repeat count");
else
    return END;
===================

if (!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
    break;
===================

if (c != ',')
    dfaerror("malformed repeat count");
===================

if (c == ',')
    for (;;) {
        {
            if (!lexleft)
                if ("unfinished repeat count" != 0)
                    dfaerror("unfinished repeat count");
                else
                    return END;
            (c) = (unsigned char)*lexptr++;
            --lexleft;
        }
        ;
        if (!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
            break;
        maxrep = 10 * maxrep + c - '0';
    }
else
    maxrep = minrep;
===================

if (!lexleft)
    if ("unfinished repeat count" != 0)
        dfaerror("unfinished repeat count");
    else
        return END;
===================

if ("unfinished repeat count" != 0)
    dfaerror("unfinished repeat count");
else
    return END;
===================

if (!(1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISdigit)))
    break;
===================

if (!(syntax_bits & (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
    if (c != '\\')
        dfaerror("malformed repeat count");
    {
        if (!lexleft)
            if ("unfinished repeat count" != 0)
                dfaerror("unfinished repeat count");
            else
                return END;
        (c) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
}
===================

if (c != '\\')
    dfaerror("malformed repeat count");
===================

if (!lexleft)
    if ("unfinished repeat count" != 0)
        dfaerror("unfinished repeat count");
    else
        return END;
===================

if ("unfinished repeat count" != 0)
    dfaerror("unfinished repeat count");
else
    return END;
===================

if (c != '}')
    dfaerror("malformed repeat count");
===================

if (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (backslash != ((syntax_bits & ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
    goto normal_char;
===================

if (syntax_bits & (((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) || backslash || !(syntax_bits & ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))
    goto normal_char;
===================

if (backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
    goto normal_char;
===================

if (backslash != ((syntax_bits & ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0))
    goto normal_char;
===================

if (parens == 0 && syntax_bits & ((((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    goto normal_char;
===================

if (backslash)
    goto normal_char;
===================

if (!(syntax_bits & (((((((1) << 1) << 1) << 1) << 1) << 1) << 1)))
    clrbit('\n', ccl);
===================

if (syntax_bits & ((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    clrbit('\x00', ccl);
===================

if (!backslash)
    goto normal_char;
===================

if ((1 && ((*__ctype_b_loc())[(int)((c2))] & (unsigned short)_ISalnum)))
    setbit(c2, ccl);
===================

if (c == 'W')
    notset(ccl);
===================

if (backslash)
    goto normal_char;
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (c == '^') {
    {
        if (!lexleft)
            if ("Unbalanced [" != 0)
                dfaerror("Unbalanced [");
            else
                return END;
        (c) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
    invert = 1;
} else
    invert = 0;
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (c == '[' && (syntax_bits & (((1) << 1) << 1)))
    for (c1 = 0; prednames[c1].name; ++c1)
        if (looking_at(prednames[c1].name)) {
            for (c2 = 0; c2 < (1 << 8); ++c2)
                if ((*prednames[c1].pred)(c2))
                    setbit(c2, ccl);
            lexptr += strlen(prednames[c1].name);
            lexleft -= strlen(prednames[c1].name);
            {
                if (!lexleft)
                    if ("Unbalanced [" != 0)
                        dfaerror("Unbalanced [");
                    else
                        return END;
                (c1) = (unsigned char)*lexptr++;
                --lexleft;
            }
            ;
            goto skip;
        }
===================

if (looking_at(prednames[c1].name)) {
    for (c2 = 0; c2 < (1 << 8); ++c2)
        if ((*prednames[c1].pred)(c2))
            setbit(c2, ccl);
    lexptr += strlen(prednames[c1].name);
    lexleft -= strlen(prednames[c1].name);
    {
        if (!lexleft)
            if ("Unbalanced [" != 0)
                dfaerror("Unbalanced [");
            else
                return END;
        (c1) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
    goto skip;
}
===================

if ((*prednames[c1].pred)(c2))
    setbit(c2, ccl);
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (c == '\\' && (syntax_bits & (1))) {
    if (!lexleft)
        if ("Unbalanced [" != 0)
            dfaerror("Unbalanced [");
        else
            return END;
    (c) = (unsigned char)*lexptr++;
    --lexleft;
}
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (c1 == '-') {
    {
        if (!lexleft)
            if ("Unbalanced [" != 0)
                dfaerror("Unbalanced [");
            else
                return END;
        (c2) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
    if (c2 == ']') {
        --lexptr;
        ++lexleft;
        c2 = c;
    } else {
        if (c2 == '\\' && (syntax_bits & (1))) {
            if (!lexleft)
                if ("Unbalanced [" != 0)
                    dfaerror("Unbalanced [");
                else
                    return END;
            (c2) = (unsigned char)*lexptr++;
            --lexleft;
        }
        ;
        {
            if (!lexleft)
                if ("Unbalanced [" != 0)
                    dfaerror("Unbalanced [");
                else
                    return END;
            (c1) = (unsigned char)*lexptr++;
            --lexleft;
        }
        ;
    }
} else
    c2 = c;
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (c2 == ']') {
    --lexptr;
    ++lexleft;
    c2 = c;
} else {
    if (c2 == '\\' && (syntax_bits & (1))) {
        if (!lexleft)
            if ("Unbalanced [" != 0)
                dfaerror("Unbalanced [");
            else
                return END;
        (c2) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
    {
        if (!lexleft)
            if ("Unbalanced [" != 0)
                dfaerror("Unbalanced [");
            else
                return END;
        (c1) = (unsigned char)*lexptr++;
        --lexleft;
    }
    ;
}
===================

if (c2 == '\\' && (syntax_bits & (1))) {
    if (!lexleft)
        if ("Unbalanced [" != 0)
            dfaerror("Unbalanced [");
        else
            return END;
    (c2) = (unsigned char)*lexptr++;
    --lexleft;
}
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (!lexleft)
    if ("Unbalanced [" != 0)
        dfaerror("Unbalanced [");
    else
        return END;
===================

if ("Unbalanced [" != 0)
    dfaerror("Unbalanced [");
else
    return END;
===================

if (case_fold)
    if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper)))
        setbit(tolower(c), ccl);
    else if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower)))
        setbit(toupper(c), ccl);
===================

if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper)))
    setbit(tolower(c), ccl);
else if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower)))
    setbit(toupper(c), ccl);
===================

if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISlower)))
    setbit(toupper(c), ccl);
===================

if (invert) {
    notset(ccl);
    if (syntax_bits & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
        clrbit('\n', ccl);
}
===================

if (syntax_bits & (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))
    clrbit('\n', ccl);
===================

if (case_fold && (1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalpha))) {
    zeroset(ccl);
    setbit(c, ccl);
    if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper))
        setbit(tolower(c), ccl);
    else
        setbit(toupper(c), ccl);
    return lasttok = CSET + charclass_index(ccl);
}
===================

if (((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISupper))
    setbit(tolower(c), ccl);
else
    setbit(toupper(c), ccl);
===================

function: addtok
if ((dfa->tindex) >= (dfa->talloc)) {
    while ((dfa->tindex) >= (dfa->talloc))
        (dfa->talloc) *= 2;
    ((dfa->tokens) = (token *)xrealloc_1((ptr_t)(dfa->tokens), (dfa->talloc) * sizeof(token)));
}
===================

if (depth > dfa->depth)
    dfa->depth = depth;
===================

function: atom
if ((tok >= 0 && tok < (1 << 8)) || tok >= CSET || tok == BACKREF || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD) {
    addtok(tok);
    tok = lex();
} else if (tok == LPAREN) {
    tok = lex();
    regexp(0);
    if (tok != RPAREN)
        dfaerror("Unbalanced (");
    tok = lex();
} else
    addtok(EMPTY);
===================

if (tok == LPAREN) {
    tok = lex();
    regexp(0);
    if (tok != RPAREN)
        dfaerror("Unbalanced (");
    tok = lex();
} else
    addtok(EMPTY);
===================

if (tok != RPAREN)
    dfaerror("Unbalanced (");
===================

function: nsubtoks
function: copytoks
function: closure
if (tok == REPMN) {
    ntokens = nsubtoks(dfa->tindex);
    tindex = dfa->tindex - ntokens;
    if (maxrep == 0)
        addtok(PLUS);
    if (minrep == 0)
        addtok(QMARK);
    for (i = 1; i < minrep; ++i) {
        copytoks(tindex, ntokens);
        addtok(CAT);
    }
    for (; i < maxrep; ++i) {
        copytoks(tindex, ntokens);
        addtok(QMARK);
        addtok(CAT);
    }
    tok = lex();
} else {
    addtok(tok);
    tok = lex();
}
===================

if (maxrep == 0)
    addtok(PLUS);
===================

if (minrep == 0)
    addtok(QMARK);
===================

function: branch
function: regexp
if (toplevel)
    addtok(ORTOP);
else
    addtok(OR);
===================

function: dfaparse
if (!syntax_bits_set)
    dfaerror("No syntax specified");
===================

if (tok != END)
    dfaerror("Unbalanced )");
===================

if (d->nregexps)
    addtok(ORTOP);
===================

function: copy
function: insert
if (i < s->nelem && p.strchr == s->elems[i].strchr)
    s->elems[i].constraint |= p.constraint;
else {
    t1 = p;
    ++s->nelem;
    while (i < s->nelem)
        {
            t2 = s->elems[i];
            s->elems[i++] = t1;
            t1 = t2;
        }
}
===================

function: merge
if (s1->elems[i].strchr > s2->elems[j].strchr)
    m->elems[m->nelem++] = s1->elems[i++];
else if (s1->elems[i].strchr < s2->elems[j].strchr)
    m->elems[m->nelem++] = s2->elems[j++];
else {
    m->elems[m->nelem] = s1->elems[i++];
    m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
}
===================

if (s1->elems[i].strchr < s2->elems[j].strchr)
    m->elems[m->nelem++] = s2->elems[j++];
else {
    m->elems[m->nelem] = s1->elems[i++];
    m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
}
===================

function: delete
if (p.strchr == s->elems[i].strchr)
    break;
===================

if (i < s->nelem)
    for (--s->nelem; i < s->nelem; ++i)
        s->elems[i] = s->elems[i + 1];
===================

function: state_index
if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem || newline != d->states[i].newline || letter != d->states[i].letter)
    continue;
===================

if (s->elems[j].constraint != d->states[i].elems.elems[j].constraint || s->elems[j].strchr != d->states[i].elems.elems[j].strchr)
    break;
===================

if (j == s->nelem)
    return i;
===================

if ((d->sindex) >= (d->salloc)) {
    while ((d->sindex) >= (d->salloc))
        (d->salloc) *= 2;
    ((d->states) = (dfa_state *)xrealloc_1((ptr_t)(d->states), (d->salloc) * sizeof(dfa_state)));
}
===================

if (d->tokens[s->elems[j].strchr] < 0) {
    constraint = s->elems[j].constraint;
    if ((((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))))
        d->states[i].constraint |= constraint;
    if (!d->states[i].first_end)
        d->states[i].first_end = d->tokens[s->elems[j].strchr];
} else if (d->tokens[s->elems[j].strchr] == BACKREF) {
    d->states[i].constraint = 255;
    d->states[i].backref = 1;
}
===================

if ((((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((0) ? 1 : 0)))) || (((constraint) & 1 << (((newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && ((constraint) & 1 << (((letter) ? 2 : 0) + ((1) ? 1 : 0)))))
    d->states[i].constraint |= constraint;
===================

if (!d->states[i].first_end)
    d->states[i].first_end = d->tokens[s->elems[j].strchr];
===================

if (d->tokens[s->elems[j].strchr] == BACKREF) {
    d->states[i].constraint = 255;
    d->states[i].backref = 1;
}
===================

function: epsclosure
if (d->tokens[s->elems[i].strchr] >= (1 << 8) && d->tokens[s->elems[i].strchr] != BACKREF && d->tokens[s->elems[i].strchr] < CSET) {
    old = s->elems[i];
    p.constraint = old.constraint;
    delete(s->elems[i], s);
    if (visited[old.strchr]) {
        --i;
        continue;
    }
    visited[old.strchr] = 1;
    switch (d->tokens[old.strchr]) {
      case BEGLINE:
        p.constraint &= 207;
        break;
      case ENDLINE:
        p.constraint &= 175;
        break;
      case BEGWORD:
        p.constraint &= 242;
        break;
      case ENDWORD:
        p.constraint &= 244;
        break;
      case LIMWORD:
        p.constraint &= 246;
        break;
      case NOTLIMWORD:
        p.constraint &= 249;
        break;
      default:
        break;
    }
    for (j = 0; j < d->follows[old.strchr].nelem; ++j) {
        p.strchr = d->follows[old.strchr].elems[j].strchr;
        insert(p, s);
    }
    i = -1;
}
===================

if (visited[old.strchr]) {
    --i;
    continue;
}
===================

function: dfaanalyze
if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) {
    while ((merged.nelem - 1) >= (nalloc[pos[j].strchr]))
        (nalloc[pos[j].strchr]) *= 2;
    ((d->follows[pos[j].strchr].elems) = (position *)xrealloc_1((ptr_t)(d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof(position)));
}
===================

if (d->tokens[i] != PLUS)
    nullable[-1] = 1;
===================

if ((merged.nelem - 1) >= (nalloc[pos[j].strchr])) {
    while ((merged.nelem - 1) >= (nalloc[pos[j].strchr]))
        (nalloc[pos[j].strchr]) *= 2;
    ((d->follows[pos[j].strchr].elems) = (position *)xrealloc_1((ptr_t)(d->follows[pos[j].strchr].elems), (nalloc[pos[j].strchr]) * sizeof(position)));
}
===================

if (nullable[-2])
    nfirstpos[-2] += nfirstpos[-1];
else
    firstpos += nfirstpos[-1];
===================

if (nullable[-1])
    nlastpos[-2] += nlastpos[-1];
else {
    pos = lastpos + nlastpos[-2];
    for (j = nlastpos[-1] - 1; j >= 0; --j)
        pos[j] = lastpos[j];
    lastpos += nlastpos[-2];
    nlastpos[-2] = nlastpos[-1];
}
===================

if (d->tokens[i] < (1 << 8) || d->tokens[i] == BACKREF || d->tokens[i] >= CSET) {
    copy(&d->follows[i], &merged);
    epsclosure(&merged, d);
    if (d->follows[i].nelem < merged.nelem)
        ((d->follows[i].elems) = (position *)xrealloc_1((ptr_t)(d->follows[i].elems), (merged.nelem) * sizeof(position)));
    copy(&merged, &d->follows[i]);
}
===================

if (d->follows[i].nelem < merged.nelem)
    ((d->follows[i].elems) = (position *)xrealloc_1((ptr_t)(d->follows[i].elems), (merged.nelem) * sizeof(position)));
===================

if ((((merged.elems[i].constraint) & 192) >> 2 != ((merged.elems[i].constraint) & 48)))
    wants_newline = 1;
===================

function: dfastate
if (!initialized) {
    initialized = 1;
    for (i = 0; i < (1 << 8); ++i)
        if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
            setbit(i, letters);
    setbit('\n', newline);
}
===================

if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
    setbit(i, letters);
===================

if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8))
    setbit(d->tokens[pos.strchr], matches);
else if (d->tokens[pos.strchr] >= CSET)
    copyset(d->charclasses[d->tokens[pos.strchr] - CSET], matches);
else
    continue;
===================

if (d->tokens[pos.strchr] >= CSET)
    copyset(d->charclasses[d->tokens[pos.strchr] - CSET], matches);
else
    continue;
===================

if (pos.constraint != 255) {
    if (!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)))
        clrbit('\n', matches);
    if (!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)))
        for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
            matches[j] &= newline[j];
    if (!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0))))
        for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
            matches[j] &= ~letters[j];
    if (!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))
        for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
            matches[j] &= letters[j];
    for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))) && !matches[j]; ++j)
        ;
    if (j == (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))))
        continue;
}
===================

if (!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)))
    clrbit('\n', matches);
===================

if (!((pos.constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)))
    for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
        matches[j] &= newline[j];
===================

if (!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0))))
    for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
        matches[j] &= ~letters[j];
===================

if (!((pos.constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0))))
    for (j = 0; j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))); ++j)
        matches[j] &= letters[j];
===================

if (j == (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))))
    continue;
===================

if (d->tokens[pos.strchr] >= 0 && d->tokens[pos.strchr] < (1 << 8) && !tstbit(d->tokens[pos.strchr], labels[j]))
    continue;
===================

if (!intersectf)
    continue;
===================

if (leftoversf) {
    copyset(leftovers, labels[ngrps]);
    copyset(intersect, labels[j]);
    ((grps[ngrps].elems) = (position *)xmalloc_1((d->nleaves) * sizeof(position)));
    copy(&grps[j], &grps[ngrps]);
    ++ngrps;
}
===================

if (!matchesf)
    break;
===================

if (j == ngrps) {
    copyset(matches, labels[ngrps]);
    zeroset(matches);
    ((grps[ngrps].elems) = (position *)xmalloc_1((d->nleaves) * sizeof(position)));
    grps[ngrps].nelem = 1;
    grps[ngrps].elems[0] = pos;
    ++ngrps;
}
===================

if (d->searchflag) {
    wants_newline = 0;
    wants_letter = 0;
    for (i = 0; i < d->states[0].elems.nelem; ++i) {
        if ((((d->states[0].elems.elems[i].constraint) & 192) >> 2 != ((d->states[0].elems.elems[i].constraint) & 48)))
            wants_newline = 1;
        if ((((d->states[0].elems.elems[i].constraint) & 12) >> 2 != ((d->states[0].elems.elems[i].constraint) & 3)))
            wants_letter = 1;
    }
    copy(&d->states[0].elems, &follows);
    state = state_index(d, &follows, 0, 0);
    if (wants_newline)
        state_newline = state_index(d, &follows, 1, 0);
    else
        state_newline = state;
    if (wants_letter)
        state_letter = state_index(d, &follows, 0, 1);
    else
        state_letter = state;
    for (i = 0; i < (1 << 8); ++i)
        if (i == '\n')
            trans[i] = state_newline;
        else if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
            trans[i] = state_letter;
        else
            trans[i] = state;
} else
    for (i = 0; i < (1 << 8); ++i)
        trans[i] = -1;
===================

if ((((d->states[0].elems.elems[i].constraint) & 192) >> 2 != ((d->states[0].elems.elems[i].constraint) & 48)))
    wants_newline = 1;
===================

if ((((d->states[0].elems.elems[i].constraint) & 12) >> 2 != ((d->states[0].elems.elems[i].constraint) & 3)))
    wants_letter = 1;
===================

if (wants_newline)
    state_newline = state_index(d, &follows, 1, 0);
else
    state_newline = state;
===================

if (wants_letter)
    state_letter = state_index(d, &follows, 0, 1);
else
    state_letter = state;
===================

if (i == '\n')
    trans[i] = state_newline;
else if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
    trans[i] = state_letter;
else
    trans[i] = state;
===================

if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
    trans[i] = state_letter;
else
    trans[i] = state;
===================

if (d->searchflag)
    for (j = 0; j < d->states[0].elems.nelem; ++j)
        insert(d->states[0].elems.elems[j], &follows);
===================

if (tstbit('\n', labels[i]))
    for (j = 0; j < follows.nelem; ++j)
        if ((((follows.elems[j].constraint) & 192) >> 2 != ((follows.elems[j].constraint) & 48)))
            wants_newline = 1;
===================

if ((((follows.elems[j].constraint) & 192) >> 2 != ((follows.elems[j].constraint) & 48)))
    wants_newline = 1;
===================

if (labels[i][j] & letters[j])
    break;
===================

if (j < (((1 << 8) + (8 * sizeof(int)) - 1) / (8 * sizeof(int))))
    for (j = 0; j < follows.nelem; ++j)
        if ((((follows.elems[j].constraint) & 12) >> 2 != ((follows.elems[j].constraint) & 3)))
            wants_letter = 1;
===================

if ((((follows.elems[j].constraint) & 12) >> 2 != ((follows.elems[j].constraint) & 3)))
    wants_letter = 1;
===================

if (wants_newline)
    state_newline = state_index(d, &follows, 1, 0);
else
    state_newline = state;
===================

if (wants_letter)
    state_letter = state_index(d, &follows, 0, 1);
else
    state_letter = state;
===================

if (labels[i][j] & 1 << k) {
    int c = j * (8 * sizeof(int)) + k;
    if (c == '\n')
        trans[c] = state_newline;
    else if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum)))
        trans[c] = state_letter;
    else if (c < (1 << 8))
        trans[c] = state;
}
===================

if (c == '\n')
    trans[c] = state_newline;
else if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum)))
    trans[c] = state_letter;
else if (c < (1 << 8))
    trans[c] = state;
===================

if ((1 && ((*__ctype_b_loc())[(int)((c))] & (unsigned short)_ISalnum)))
    trans[c] = state_letter;
else if (c < (1 << 8))
    trans[c] = state;
===================

if (c < (1 << 8))
    trans[c] = state;
===================

function: build_state
if (d->trcount >= 1024) {
    for (i = 0; i < d->tralloc; ++i)
        if (d->trans[i]) {
            free((ptr_t)d->trans[i]);
            d->trans[i] = ((void *)0);
        } else if (d->fails[i]) {
            free((ptr_t)d->fails[i]);
            d->fails[i] = ((void *)0);
        }
    d->trcount = 0;
}
===================

if (d->trans[i]) {
    free((ptr_t)d->trans[i]);
    d->trans[i] = ((void *)0);
} else if (d->fails[i]) {
    free((ptr_t)d->fails[i]);
    d->fails[i] = ((void *)0);
}
===================

if (d->fails[i]) {
    free((ptr_t)d->fails[i]);
    d->fails[i] = ((void *)0);
}
===================

if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((1) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))))
    d->success[s] |= 4;
===================

if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((1) ? 1 : 0)))))
    d->success[s] |= 2;
===================

if (((((*d).states[s].constraint) & 1 << (((d->states[s].newline) ? 2 : 0) + ((0) ? 1 : 0) + 4)) && (((*d).states[s].constraint) & 1 << (((d->states[s].letter) ? 2 : 0) + ((0) ? 1 : 0)))))
    d->success[s] |= 1;
===================

if (trans[i] >= d->tralloc) {
    int oldalloc = d->tralloc;
    while (trans[i] >= d->tralloc)
        d->tralloc *= 2;
    ((d->realtrans) = (int **)xrealloc_1((ptr_t)(d->realtrans), (d->tralloc + 1) * sizeof(int *)));
    d->trans = d->realtrans + 1;
    ((d->fails) = (int **)xrealloc_1((ptr_t)(d->fails), (d->tralloc) * sizeof(int *)));
    ((d->success) = (int *)xrealloc_1((ptr_t)(d->success), (d->tralloc) * sizeof(int)));
    ((d->newlines) = (int *)xrealloc_1((ptr_t)(d->newlines), (d->tralloc) * sizeof(int)));
    while (oldalloc < d->tralloc)
        {
            d->trans[oldalloc] = ((void *)0);
            d->fails[oldalloc++] = ((void *)0);
        }
}
===================

if (((*d).states[s].constraint))
    d->fails[s] = trans;
else
    d->trans[s] = trans;
===================

function: build_state_zero
function: dfaexec
if (!sbit_init) {
    int i;
    sbit_init = 1;
    for (i = 0; i < (1 << 8); ++i)
        if (i == '\n')
            sbit[i] = 4;
        else if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
            sbit[i] = 2;
        else
            sbit[i] = 1;
}
===================

if (i == '\n')
    sbit[i] = 4;
else if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
    sbit[i] = 2;
else
    sbit[i] = 1;
===================

if ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISalnum)))
    sbit[i] = 2;
else
    sbit[i] = 1;
===================

if (!d->tralloc)
    build_state_zero(d);
===================

if ((t = trans[s]) != 0)
    do {
        s1 = t[*p++];
        if (!(t = trans[s1]))
            goto last_was_s;
        s = t[*p++];
    } while ((t = trans[s]) != 0);
===================

if (!(t = trans[s1]))
    goto last_was_s;
===================

if (s >= 0 && p <= (unsigned char *)end && d->fails[s]) {
    if (d->success[s] & sbit[*p]) {
        if (backref)
            if (d->states[s].backref)
                *backref = 1;
            else
                *backref = 0;
        return (char *)p;
    }
    s1 = s;
    s = d->fails[s][*p++];
    continue;
}
===================

if (d->success[s] & sbit[*p]) {
    if (backref)
        if (d->states[s].backref)
            *backref = 1;
        else
            *backref = 0;
    return (char *)p;
}
===================

if (backref)
    if (d->states[s].backref)
        *backref = 1;
    else
        *backref = 0;
===================

if (d->states[s].backref)
    *backref = 1;
else
    *backref = 0;
===================

if (count && (char *)p <= end && p[-1] == '\n')
    ++*count;
===================

if ((char *)p > end)
    return ((void *)0);
===================

if (s >= 0) {
    build_state(s, d);
    trans = d->trans;
    continue;
}
===================

if (p[-1] == '\n' && newline) {
    s = d->newlines[s1];
    continue;
}
===================

function: dfainit
function: dfacomp
if (case_fold) {
    char *copy;
    int i;
    copy = malloc(len);
    if (!copy)
        dfaerror("out of memory");
    case_fold = 0;
    for (i = 0; i < len; ++i)
        if ((1 && ((*__ctype_b_loc())[(int)((s[i]))] & (unsigned short)_ISupper)))
            copy[i] = tolower(s[i]);
        else
            copy[i] = s[i];
    dfainit(d);
    dfaparse(copy, len, d);
    free(copy);
    dfamust(d);
    d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
    case_fold = 1;
    dfaparse(s, len, d);
    dfaanalyze(d, searchflag);
} else {
    dfainit(d);
    dfaparse(s, len, d);
    dfamust(d);
    dfaanalyze(d, searchflag);
}
===================

if (!copy)
    dfaerror("out of memory");
===================

if ((1 && ((*__ctype_b_loc())[(int)((s[i]))] & (unsigned short)_ISupper)))
    copy[i] = tolower(s[i]);
else
    copy[i] = s[i];
===================

function: dfafree
if (d->follows[i].elems)
    free((ptr_t)d->follows[i].elems);
===================

if (d->trans[i])
    free((ptr_t)d->trans[i]);
else if (d->fails[i])
    free((ptr_t)d->fails[i]);
===================

if (d->fails[i])
    free((ptr_t)d->fails[i]);
===================

function: icatalloc
if (old == ((void *)0))
    oldsize = 0;
else if (newsize == 0)
    return old;
else
    oldsize = strlen(old);
===================

if (newsize == 0)
    return old;
else
    oldsize = strlen(old);
===================

if (old == ((void *)0))
    result = (char *)malloc(newsize + 1);
else
    result = (char *)realloc((void *)old, oldsize + newsize + 1);
===================

if (result != ((void *)0) && new != ((void *)0))
    (void)strcpy(result + oldsize, new);
===================

function: icpyalloc
function: istrstr
if (strncmp(cp, lookfor, len) == 0)
    return cp;
===================

function: ifree
if (cp != ((void *)0))
    free(cp);
===================

function: freelist
if (cpp == ((void *)0))
    return;
===================

function: enlist
if (cpp == ((void *)0))
    return ((void *)0);
===================

if ((new = icpyalloc(new)) == ((void *)0)) {
    freelist(cpp);
    return ((void *)0);
}
===================

if (istrstr(cpp[i], new) != ((void *)0)) {
    free(new);
    return cpp;
}
===================

if (istrstr(new, cpp[j]) == ((void *)0))
    ++j;
else {
    free(cpp[j]);
    if (--i == j)
        break;
    cpp[j] = cpp[i];
    cpp[i] = ((void *)0);
}
===================

if (--i == j)
    break;
===================

if (cpp == ((void *)0))
    return ((void *)0);
===================

function: comsubs
if (left == ((void *)0) || right == ((void *)0))
    return ((void *)0);
===================

if (cpp == ((void *)0))
    return ((void *)0);
===================

if (i > len)
    len = i;
===================

if (len == 0)
    continue;
===================

if ((cpp = enlist(cpp, lcp, len)) == ((void *)0))
    break;
===================

function: addlists
if (old == ((void *)0) || new == ((void *)0))
    return ((void *)0);
===================

if (old == ((void *)0))
    break;
===================

function: inboth
if (left == ((void *)0) || right == ((void *)0))
    return ((void *)0);
===================

if (both == ((void *)0))
    return ((void *)0);
===================

if (temp == ((void *)0)) {
    freelist(both);
    return ((void *)0);
}
===================

if (both == ((void *)0))
    return ((void *)0);
===================

function: resetmust
function: dfamust
if (musts == ((void *)0))
    return;
===================

if (mp[i].in == ((void *)0) || mp[i].left == ((void *)0) || mp[i].right == ((void *)0) || mp[i].is == ((void *)0))
    goto done;
===================

if (mp <= musts)
    goto done;
===================

if (mp < &musts[2])
    goto done;
===================

if (strcmp(lmp->is, rmp->is) != 0)
    lmp->is[0] = '\x00';
===================

if (n > rn)
    n = rn;
===================

if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
    break;
===================

if (new == ((void *)0))
    goto done;
===================

if (mp <= musts)
    goto done;
===================

if (mp != &musts[1])
    goto done;
===================

if (strlen(musts[0].in[i]) > strlen(result))
    result = musts[0].in[i];
===================

if (strcmp(result, musts[0].is) == 0)
    exact = 1;
===================

if (mp < &musts[2])
    goto done;
===================

if (lmp->in == ((void *)0))
    goto done;
===================

if (lmp->right[0] != '\x00' && rmp->left[0] != '\x00') {
    char *tp;
    tp = icpyalloc(lmp->right);
    if (tp == ((void *)0))
        goto done;
    tp = icatalloc(tp, rmp->left);
    if (tp == ((void *)0))
        goto done;
    lmp->in = enlist(lmp->in, tp, strlen(tp));
    free(tp);
    if (lmp->in == ((void *)0))
        goto done;
}
===================

if (tp == ((void *)0))
    goto done;
===================

if (tp == ((void *)0))
    goto done;
===================

if (lmp->in == ((void *)0))
    goto done;
===================

if (lmp->is[0] != '\x00') {
    lmp->left = icatalloc(lmp->left, rmp->left);
    if (lmp->left == ((void *)0))
        goto done;
}
===================

if (lmp->left == ((void *)0))
    goto done;
===================

if (rmp->is[0] == '\x00')
    lmp->right[0] = '\x00';
===================

if (lmp->right == ((void *)0))
    goto done;
===================

if (lmp->is[0] != '\x00' && rmp->is[0] != '\x00') {
    lmp->is = icatalloc(lmp->is, rmp->is);
    if (lmp->is == ((void *)0))
        goto done;
} else
    lmp->is[0] = '\x00';
===================

if (lmp->is == ((void *)0))
    goto done;
===================

if (t < END) {
    goto done;
} else if (t == '\x00') {
    goto done;
} else if (t >= CSET) {
    resetmust(mp);
} else {
    resetmust(mp);
    mp->is[0] = mp->left[0] = mp->right[0] = t;
    mp->is[1] = mp->left[1] = mp->right[1] = '\x00';
    mp->in = enlist(mp->in, mp->is, 1);
    if (mp->in == ((void *)0))
        goto done;
}
===================

if (t == '\x00') {
    goto done;
} else if (t >= CSET) {
    resetmust(mp);
} else {
    resetmust(mp);
    mp->is[0] = mp->left[0] = mp->right[0] = t;
    mp->is[1] = mp->left[1] = mp->right[1] = '\x00';
    mp->in = enlist(mp->in, mp->is, 1);
    if (mp->in == ((void *)0))
        goto done;
}
===================

if (t >= CSET) {
    resetmust(mp);
} else {
    resetmust(mp);
    mp->is[0] = mp->left[0] = mp->right[0] = t;
    mp->is[1] = mp->left[1] = mp->right[1] = '\x00';
    mp->in = enlist(mp->in, mp->is, 1);
    if (mp->in == ((void *)0))
        goto done;
}
===================

if (mp->in == ((void *)0))
    goto done;
===================

if (strlen(result)) {
    dm = (struct dfamust *)malloc(sizeof(struct dfamust));
    dm->exact = exact;
    dm->must = malloc(strlen(result) + 1);
    strcpy(dm->must, result);
    dm->next = dfa->musts;
    dfa->musts = dm;
}
===================

function: xmalloc
function: kwsalloc
if (!kwset)
    return 0;
===================

if (__o1->next_free == value)
    __o1->maybe_empty_object = 1;
===================

if (!kwset->trie) {
    kwsfree((kwset_t)kwset);
    return 0;
}
===================

function: kwsincr
if (label < link->label)
    dirs[depth++] = L , link = link->llink;
else
    dirs[depth++] = R , link = link->rlink;
===================

if (!link) {
    link = (struct tree *)__extension__ ({
        struct obstack *__h = (&kwset->obstack);
        __extension__ ({
            struct obstack *__o = (__h);
            int __len = ((sizeof(struct tree)));
            ((__o->chunk_limit - __o->next_free < __len) ? (_obstack_newchunk(__o, __len) , 0) : 0);
            __o->next_free += __len;
            (void)0;
        });
        __extension__ ({
            struct obstack *__o1 = (__h);
            void *value = (void *)__o1->object_base;
            if (__o1->next_free == value)
                __o1->maybe_empty_object = 1;
            __o1->next_free = (((((__o1->next_free) - (char *)0) + __o1->alignment_mask) & ~(__o1->alignment_mask)) + (char *)0);
            ((__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) ? (__o1->next_free = __o1->chunk_limit) : 0);
            __o1->object_base = __o1->next_free;
            value;
        });
    });
    if (!link)
        return "memory exhausted";
    link->llink = 0;
    link->rlink = 0;
    link->trie = (struct trie *)__extension__ ({
        struct obstack *__h = (&kwset->obstack);
        __extension__ ({
            struct obstack *__o = (__h);
            int __len = ((sizeof(struct trie)));
            ((__o->chunk_limit - __o->next_free < __len) ? (_obstack_newchunk(__o, __len) , 0) : 0);
            __o->next_free += __len;
            (void)0;
        });
        __extension__ ({
            struct obstack *__o1 = (__h);
            void *value = (void *)__o1->object_base;
            if (__o1->next_free == value)
                __o1->maybe_empty_object = 1;
            __o1->next_free = (((((__o1->next_free) - (char *)0) + __o1->alignment_mask) & ~(__o1->alignment_mask)) + (char *)0);
            ((__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) ? (__o1->next_free = __o1->chunk_limit) : 0);
            __o1->object_base = __o1->next_free;
            value;
        });
    });
    if (!link->trie)
        return "memory exhausted";
    link->trie->accepting = 0;
    link->trie->links = 0;
    link->trie->parent = trie;
    link->trie->next = 0;
    link->trie->fail = 0;
    link->trie->depth = trie->depth + 1;
    link->trie->shift = 0;
    link->label = label;
    link->balance = 0;
    if (dirs[--depth] == L)
        links[depth]->llink = link;
    else
        links[depth]->rlink = link;
    while (depth && !links[depth]->balance)
        {
            if (dirs[depth] == L)
                --links[depth]->balance;
            else
                ++links[depth]->balance;
            --depth;
        }
    if (depth && ((dirs[depth] == L && --links[depth]->balance) || (dirs[depth] == R && ++links[depth]->balance))) {
        switch (links[depth]->balance) {
          case (char)-2:
            switch (dirs[depth + 1]) {
              case L:
                r = links[depth] , t = r->llink , rl = t->rlink;
                t->rlink = r , r->llink = rl;
                t->balance = r->balance = 0;
                break;
              case R:
                r = links[depth] , l = r->llink , t = l->rlink;
                rl = t->rlink , lr = t->llink;
                t->llink = l , l->rlink = lr , t->rlink = r , r->llink = rl;
                l->balance = t->balance != 1 ? 0 : -1;
                r->balance = t->balance != (char)-1 ? 0 : 1;
                t->balance = 0;
                break;
            }
            break;
          case 2:
            switch (dirs[depth + 1]) {
              case R:
                l = links[depth] , t = l->rlink , lr = t->llink;
                t->llink = l , l->rlink = lr;
                t->balance = l->balance = 0;
                break;
              case L:
                l = links[depth] , r = l->rlink , t = r->llink;
                lr = t->llink , rl = t->rlink;
                t->llink = l , l->rlink = lr , t->rlink = r , r->llink = rl;
                l->balance = t->balance != 1 ? 0 : -1;
                r->balance = t->balance != (char)-1 ? 0 : 1;
                t->balance = 0;
                break;
            }
            break;
        }
        if (dirs[depth - 1] == L)
            links[depth - 1]->llink = t;
        else
            links[depth - 1]->rlink = t;
    }
}
===================

if (__o1->next_free == value)
    __o1->maybe_empty_object = 1;
===================

if (!link)
    return "memory exhausted";
===================

if (__o1->next_free == value)
    __o1->maybe_empty_object = 1;
===================

if (!link->trie)
    return "memory exhausted";
===================

if (dirs[--depth] == L)
    links[depth]->llink = link;
else
    links[depth]->rlink = link;
===================

if (dirs[depth] == L)
    --links[depth]->balance;
else
    ++links[depth]->balance;
===================

if (depth && ((dirs[depth] == L && --links[depth]->balance) || (dirs[depth] == R && ++links[depth]->balance))) {
    switch (links[depth]->balance) {
      case (char)-2:
        switch (dirs[depth + 1]) {
          case L:
            r = links[depth] , t = r->llink , rl = t->rlink;
            t->rlink = r , r->llink = rl;
            t->balance = r->balance = 0;
            break;
          case R:
            r = links[depth] , l = r->llink , t = l->rlink;
            rl = t->rlink , lr = t->llink;
            t->llink = l , l->rlink = lr , t->rlink = r , r->llink = rl;
            l->balance = t->balance != 1 ? 0 : -1;
            r->balance = t->balance != (char)-1 ? 0 : 1;
            t->balance = 0;
            break;
        }
        break;
      case 2:
        switch (dirs[depth + 1]) {
          case R:
            l = links[depth] , t = l->rlink , lr = t->llink;
            t->llink = l , l->rlink = lr;
            t->balance = l->balance = 0;
            break;
          case L:
            l = links[depth] , r = l->rlink , t = r->llink;
            lr = t->llink , rl = t->rlink;
            t->llink = l , l->rlink = lr , t->rlink = r , r->llink = rl;
            l->balance = t->balance != 1 ? 0 : -1;
            r->balance = t->balance != (char)-1 ? 0 : 1;
            t->balance = 0;
            break;
        }
        break;
    }
    if (dirs[depth - 1] == L)
        links[depth - 1]->llink = t;
    else
        links[depth - 1]->rlink = t;
}
===================

if (dirs[depth - 1] == L)
    links[depth - 1]->llink = t;
else
    links[depth - 1]->rlink = t;
===================

if (!trie->accepting)
    trie->accepting = 1 + 2 * kwset->words;
===================

if (trie->depth < kwset->mind)
    kwset->mind = trie->depth;
===================

if (trie->depth > kwset->maxd)
    kwset->maxd = trie->depth;
===================

function: enqueue
if (!tree)
    return;
===================

function: treefails
if (!tree)
    return;
===================

if (tree->label < link->label)
    link = link->llink;
else
    link = link->rlink;
===================

if (link) {
    tree->trie->fail = link->trie;
    return;
}
===================

function: treedelta
if (!tree)
    return;
===================

if (depth < delta[tree->label])
    delta[tree->label] = depth;
===================

function: hasevery
if (!b)
    return 1;
===================

if (!hasevery(a, b->llink))
    return 0;
===================

if (!hasevery(a, b->rlink))
    return 0;
===================

if (b->label < a->label)
    a = a->llink;
else
    a = a->rlink;
===================

function: treenext
if (!tree)
    return;
===================

function: kwsprep
if (kwset->mind < 256)
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        delta[i] = kwset->mind;
else
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        delta[i] = 255;
===================

if (kwset->words == 1 && kwset->trans == 0) {
    kwset->target = __extension__ ({
        struct obstack *__h = (&kwset->obstack);
        __extension__ ({
            struct obstack *__o = (__h);
            int __len = ((kwset->mind));
            ((__o->chunk_limit - __o->next_free < __len) ? (_obstack_newchunk(__o, __len) , 0) : 0);
            __o->next_free += __len;
            (void)0;
        });
        __extension__ ({
            struct obstack *__o1 = (__h);
            void *value = (void *)__o1->object_base;
            if (__o1->next_free == value)
                __o1->maybe_empty_object = 1;
            __o1->next_free = (((((__o1->next_free) - (char *)0) + __o1->alignment_mask) & ~(__o1->alignment_mask)) + (char *)0);
            ((__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) ? (__o1->next_free = __o1->chunk_limit) : 0);
            __o1->object_base = __o1->next_free;
            value;
        });
    });
    for (i = kwset->mind - 1 , curr = kwset->trie; i >= 0; --i) {
        kwset->target[i] = curr->links->label;
        curr = curr->links->trie;
    }
    for (i = 0; i < kwset->mind; ++i)
        delta[(unsigned char)kwset->target[i]] = kwset->mind - (i + 1);
    kwset->mind2 = kwset->mind;
    for (i = 0; i < kwset->mind - 1; ++i)
        if (kwset->target[i] == kwset->target[kwset->mind - 1])
            kwset->mind2 = kwset->mind - (i + 1);
} else {
    for (curr = last = kwset->trie; curr; curr = curr->next) {
        enqueue(curr->links, &last);
        curr->shift = kwset->mind;
        curr->maxshift = kwset->mind;
        treedelta(curr->links, curr->depth, delta);
        treefails(curr->links, curr->fail, kwset->trie);
        for (fail = curr->fail; fail; fail = fail->fail) {
            if (!hasevery(fail->links, curr->links))
                if (curr->depth - fail->depth < fail->shift)
                    fail->shift = curr->depth - fail->depth;
            if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
                fail->maxshift = curr->depth - fail->depth;
        }
    }
    for (curr = kwset->trie->next; curr; curr = curr->next) {
        if (curr->maxshift > curr->parent->maxshift)
            curr->maxshift = curr->parent->maxshift;
        if (curr->shift > curr->maxshift)
            curr->shift = curr->maxshift;
    }
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        next[i] = 0;
    treenext(kwset->trie->links, next);
    if ((trans = kwset->trans) != 0)
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
            kwset->next[i] = next[(unsigned char)trans[i]];
    else
        for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
            kwset->next[i] = next[i];
}
===================

if (__o1->next_free == value)
    __o1->maybe_empty_object = 1;
===================

if (kwset->target[i] == kwset->target[kwset->mind - 1])
    kwset->mind2 = kwset->mind - (i + 1);
===================

if (!hasevery(fail->links, curr->links))
    if (curr->depth - fail->depth < fail->shift)
        fail->shift = curr->depth - fail->depth;
===================

if (curr->depth - fail->depth < fail->shift)
    fail->shift = curr->depth - fail->depth;
===================

if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
    fail->maxshift = curr->depth - fail->depth;
===================

if (curr->maxshift > curr->parent->maxshift)
    curr->maxshift = curr->parent->maxshift;
===================

if (curr->shift > curr->maxshift)
    curr->shift = curr->maxshift;
===================

if ((trans = kwset->trans) != 0)
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        kwset->next[i] = next[(unsigned char)trans[i]];
else
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        kwset->next[i] = next[i];
===================

if ((trans = kwset->trans) != 0)
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        kwset->delta[i] = delta[(unsigned char)trans[i]];
else
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        kwset->delta[i] = delta[i];
===================

function: bmexec
if (len == 0)
    return text;
===================

if (len > size)
    return 0;
===================

if (len == 1)
    return memchr(text, kwset->target[0], size);
===================

if (size > 12 * len)
    for (ep = text + size - 11 * len; ;) {
        while (tp <= ep)
            {
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                if (d == 0)
                    goto found;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                if (d == 0)
                    goto found;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                if (d == 0)
                    goto found;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
                d = d1[((unsigned char)(tp[-1]))] , tp += d;
            }
        break;
      found:
        if (((unsigned char)(tp[-2])) == gc) {
            for (i = 3; i <= len && ((unsigned char)(tp[-i])) == ((unsigned char)(sp[-i])); ++i)
                ;
            if (i > len)
                return tp - len;
        }
        tp += md2;
    }
===================

if (d == 0)
    goto found;
===================

if (d == 0)
    goto found;
===================

if (d == 0)
    goto found;
===================

if (((unsigned char)(tp[-2])) == gc) {
    for (i = 3; i <= len && ((unsigned char)(tp[-i])) == ((unsigned char)(sp[-i])); ++i)
        ;
    if (i > len)
        return tp - len;
}
===================

if (i > len)
    return tp - len;
===================

if (d != 0)
    continue;
===================

if (tp[-2] == gc) {
    for (i = 3; i <= len && ((unsigned char)(tp[-i])) == ((unsigned char)(sp[-i])); ++i)
        ;
    if (i > len)
        return tp - len;
}
===================

if (i > len)
    return tp - len;
===================

function: cwexec
if (len < kwset->mind)
    return 0;
===================

if ((d = kwset->mind) != 0)
    mch = 0;
else {
    mch = text , accept = kwset->trie;
    goto match;
}
===================

if (len >= 4 * kwset->mind)
    qlim = lim - 4 * kwset->mind;
else
    qlim = 0;
===================

if (qlim && end <= qlim) {
    end += d - 1;
    while ((d = delta[c = *end]) && end < qlim)
        {
            end += d;
            end += delta[(unsigned char)*end];
            end += delta[(unsigned char)*end];
        }
    ++end;
} else
    d = delta[c = (end += d)[-1]];
===================

if (d)
    continue;
===================

if (trie->accepting) {
    mch = beg;
    accept = trie;
}
===================

if (c < tree->label)
    tree = tree->llink;
else
    tree = tree->rlink;
===================

if (tree) {
    trie = tree->trie;
    if (trie->accepting) {
        mch = beg;
        accept = trie;
    }
} else
    break;
===================

if (trie->accepting) {
    mch = beg;
    accept = trie;
}
===================

if (mch)
    goto match;
===================

if (lim - mch > kwset->maxd)
    lim = mch + kwset->maxd;
===================

if ((d = delta[c = (end += d)[-1]]) != 0)
    continue;
===================

if (!(trie = next[c])) {
    d = 1;
    continue;
}
===================

if (trie->accepting && beg <= mch) {
    lmch = beg;
    accept = trie;
}
===================

if (c < tree->label)
    tree = tree->llink;
else
    tree = tree->rlink;
===================

if (tree) {
    trie = tree->trie;
    if (trie->accepting && beg <= mch) {
        lmch = beg;
        accept = trie;
    }
} else
    break;
===================

if (trie->accepting && beg <= mch) {
    lmch = beg;
    accept = trie;
}
===================

if (lmch) {
    mch = lmch;
    goto match;
}
===================

if (!d)
    d = 1;
===================

if (kwsmatch) {
    kwsmatch->strchr = accept->accepting / 2;
    kwsmatch->beg[0] = mch;
    kwsmatch->size[0] = accept->depth;
}
===================

function: kwsexec
if (kwset->words == 1 && kwset->trans == 0) {
    ret = bmexec(kws, text, size);
    if (kwsmatch != 0 && ret != 0) {
        kwsmatch->strchr = 0;
        kwsmatch->beg[0] = ret;
        kwsmatch->size[0] = kwset->mind;
    }
    return ret;
} else
    return cwexec(kws, text, size, kwsmatch);
===================

if (kwsmatch != 0 && ret != 0) {
    kwsmatch->strchr = 0;
    kwsmatch->beg[0] = ret;
    kwsmatch->size[0] = kwset->mind;
}
===================

function: kwsfree
if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)
    __o->next_free = __o->object_base = __obj;
else
    (obstack_free)(__o, __obj);
===================

function: dfaerror
function: kwsinit
if (match_icase)
    for (i = 0; i < ((127 * 2 + 1) + 1); ++i)
        trans[i] = ((1 && ((*__ctype_b_loc())[(int)((i))] & (unsigned short)_ISupper)) ? tolower(i) : (i));
===================

if (!(kwset = kwsalloc(match_icase ? trans : (char *)0)))
    fatal("memory exhausted", 0);
===================

function: kwsmusts
if (dfa_1.musts) {
    kwsinit();
    for (dm = dfa_1.musts; dm; dm = dm->next) {
        if (!dm->exact)
            continue;
        ++lastexact;
        if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
            fatal(err, 0);
    }
    for (dm = dfa_1.musts; dm; dm = dm->next) {
        if (dm->exact)
            continue;
        if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
            fatal(err, 0);
    }
    if ((err = kwsprep(kwset)) != 0)
        fatal(err, 0);
}
===================

if (!dm->exact)
    continue;
===================

if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    fatal(err, 0);
===================

if (dm->exact)
    continue;
===================

if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    fatal(err, 0);
===================

if ((err = kwsprep(kwset)) != 0)
    fatal(err, 0);
===================

function: Gcompile
if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    fatal(err, 0);
===================

if (match_words || match_lines) {
    char *n = xmalloc(size + 50);
    int i = 0;
    strcpy(n, "");
    if (match_lines)
        strcpy(n, "^\\(");
    if (match_words)
        strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
    i = strlen(n);
    memcpy((n + i), (pattern), (size));
    i += size;
    if (match_words)
        strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
    if (match_lines)
        strcpy(n + i, "\\)$");
    i += strlen(n + i);
    dfacomp(n, i, &dfa_1, 1);
} else
    dfacomp(pattern, size, &dfa_1, 1);
===================

if (match_lines)
    strcpy(n, "^\\(");
===================

if (match_words)
    strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
===================

if (match_words)
    strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
===================

if (match_lines)
    strcpy(n + i, "\\)$");
===================

function: Ecompile
if (strcmp(matcher, "posix-egrep") == 0) {
    re_set_syntax((((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
    dfasyntax((((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | (((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase);
} else {
    re_set_syntax(((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
    dfasyntax(((((1) << 1) << 1) | ((((1) << 1) << 1) << 1) | (((((1) << 1) << 1) << 1) << 1) | (((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((((((((1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)), match_icase);
}
===================

if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    fatal(err, 0);
===================

if (match_words || match_lines) {
    char *n = xmalloc(size + 50);
    int i = 0;
    strcpy(n, "");
    if (match_lines)
        strcpy(n, "^(");
    if (match_words)
        strcpy(n, "(^|[^0-9A-Za-z_])(");
    i = strlen(n);
    memcpy((n + i), (pattern), (size));
    i += size;
    if (match_words)
        strcpy(n + i, ")([^0-9A-Za-z_]|$)");
    if (match_lines)
        strcpy(n + i, ")$");
    i += strlen(n + i);
    dfacomp(n, i, &dfa_1, 1);
} else
    dfacomp(pattern, size, &dfa_1, 1);
===================

if (match_lines)
    strcpy(n, "^(");
===================

if (match_words)
    strcpy(n, "(^|[^0-9A-Za-z_])(");
===================

if (match_words)
    strcpy(n + i, ")([^0-9A-Za-z_]|$)");
===================

if (match_lines)
    strcpy(n + i, ")$");
===================

function: EGexecute
if (kwset) {
    beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
    if (!beg)
        goto failure;
    end = memchr(beg, '\n', buflim - beg);
    if (!end)
        end = buflim;
    while (beg > buf && beg[-1] != '\n')
        --beg;
    save = *end;
    if (kwsm.strchr < lastexact)
        goto success;
    if (!dfaexec(&dfa_1, beg, end, 0, (int *)0, &backref)) {
        *end = save;
        continue;
    }
    *end = save;
    if (!backref)
        goto success;
} else {
    save = *buflim;
    beg = dfaexec(&dfa_1, beg, buflim, 0, (int *)0, &backref);
    *buflim = save;
    if (!beg)
        goto failure;
    end = memchr(beg, '\n', buflim - beg);
    if (!end)
        end = buflim;
    while (beg > buf && beg[-1] != '\n')
        --beg;
    if (!backref)
        goto success;
}
===================

if (!beg)
    goto failure;
===================

if (!end)
    end = buflim;
===================

if (kwsm.strchr < lastexact)
    goto success;
===================

if (!dfaexec(&dfa_1, beg, end, 0, (int *)0, &backref)) {
    *end = save;
    continue;
}
===================

if (!backref)
    goto success;
===================

if (!beg)
    goto failure;
===================

if (!end)
    end = buflim;
===================

if (!backref)
    goto success;
===================

if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0) {
    len = regs.end[0] - start;
    if (!match_lines && !match_words || match_lines && len == end - beg)
        goto success;
    if (match_words)
        while (start >= 0)
            {
                if ((start == 0 || !((1 && ((*__ctype_b_loc())[(int)((beg[start - 1]))] & (unsigned short)_ISalnum)) || (beg[start - 1]) == '_')) && (len == end - beg || !((1 && ((*__ctype_b_loc())[(int)((beg[start + len]))] & (unsigned short)_ISalnum)) || (beg[start + len]) == '_')))
                    goto success;
                if (len > 0) {
                    --len;
                    regex.not_eol = 1;
                    len = re_match(&regex, beg, start + len, start, &regs);
                }
                if (len <= 0) {
                    if (start == end - beg)
                        break;
                    ++start;
                    regex.not_eol = 0;
                    start = re_search(&regex, beg, end - beg, start, end - beg - start, &regs);
                    len = regs.end[0] - start;
                }
            }
}
===================

if (!match_lines && !match_words || match_lines && len == end - beg)
    goto success;
===================

if (match_words)
    while (start >= 0)
        {
            if ((start == 0 || !((1 && ((*__ctype_b_loc())[(int)((beg[start - 1]))] & (unsigned short)_ISalnum)) || (beg[start - 1]) == '_')) && (len == end - beg || !((1 && ((*__ctype_b_loc())[(int)((beg[start + len]))] & (unsigned short)_ISalnum)) || (beg[start + len]) == '_')))
                goto success;
            if (len > 0) {
                --len;
                regex.not_eol = 1;
                len = re_match(&regex, beg, start + len, start, &regs);
            }
            if (len <= 0) {
                if (start == end - beg)
                    break;
                ++start;
                regex.not_eol = 0;
                start = re_search(&regex, beg, end - beg, start, end - beg - start, &regs);
                len = regs.end[0] - start;
            }
        }
===================

if ((start == 0 || !((1 && ((*__ctype_b_loc())[(int)((beg[start - 1]))] & (unsigned short)_ISalnum)) || (beg[start - 1]) == '_')) && (len == end - beg || !((1 && ((*__ctype_b_loc())[(int)((beg[start + len]))] & (unsigned short)_ISalnum)) || (beg[start + len]) == '_')))
    goto success;
===================

if (len > 0) {
    --len;
    regex.not_eol = 1;
    len = re_match(&regex, beg, start + len, start, &regs);
}
===================

if (len <= 0) {
    if (start == end - beg)
        break;
    ++start;
    regex.not_eol = 0;
    start = re_search(&regex, beg, end - beg, start, end - beg - start, &regs);
    len = regs.end[0] - start;
}
===================

if (start == end - beg)
    break;
===================

function: Fcompile
if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
    fatal(err, 0);
===================

if (lim < pattern + size)
    ++lim;
===================

if ((err = kwsprep(kwset)) != 0)
    fatal(err, 0);
===================

function: Fexecute
if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
    return 0;
===================

if (match_lines) {
    if (beg > buf && beg[-1] != '\n')
        continue;
    if (beg + len < buf + size && beg[len] != '\n')
        continue;
    goto success;
} else if (match_words)
    for (try = beg; len && try;) {
        if (try > buf && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[-1]) == '_'))
            break;
        if (try + len < buf + size && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[len]) == '_')) {
            try = kwsexec(kwset, beg, --len, &kwsmatch);
            len = kwsmatch.size[0];
        } else
            goto success;
    }
else
    goto success;
===================

if (beg > buf && beg[-1] != '\n')
    continue;
===================

if (beg + len < buf + size && beg[len] != '\n')
    continue;
===================

if (match_words)
    for (try = beg; len && try;) {
        if (try > buf && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[-1]) == '_'))
            break;
        if (try + len < buf + size && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[len]) == '_')) {
            try = kwsexec(kwset, beg, --len, &kwsmatch);
            len = kwsmatch.size[0];
        } else
            goto success;
    }
else
    goto success;
===================

if (try > buf && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[-1]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[-1]) == '_'))
    break;
===================

if (try + len < buf + size && ((1 && ((*__ctype_b_loc())[(int)(((unsigned char)try[len]))] & (unsigned short)_ISalnum)) || ((unsigned char)try[len]) == '_')) {
    try = kwsexec(kwset, beg, --len, &kwsmatch);
    len = kwsmatch.size[0];
} else
    goto success;
===================

if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
    ++end;
else
    end = buf + size;
===================

Total number of branches: 0
